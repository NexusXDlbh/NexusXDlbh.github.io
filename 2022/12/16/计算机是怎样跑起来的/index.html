<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=EB Garamond, 'Noto Serif SC':300,300italic,400,400italic,700,700italic|Cinzel Decorative:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nexuslbh.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机是怎样跑起来的-linux0.11源代码学习">
<meta property="og:url" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/index.html">
<meta property="og:site_name" content="Meta Field">
<meta property="og:description" content="而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/mbr.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cp.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/go.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/in.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/m1.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/m2.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/seg.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/gdtm.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/gdtr.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/z1.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/dxzz.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/gdt.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/f.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/segpage.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/yb.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr04.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr0.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr2.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr3.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/lc.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/memory.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/memdis.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/meminit.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/request.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/picbuf.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/shell.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/tss.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/bu.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/bh.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/freelist.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/hstb.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/yht.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/stack.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/fo.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cu.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/fz.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/sz.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/blk1.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/hd.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/hdfq.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/wjxt.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/filp.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/intel.png">
<meta property="og:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/ERRORCODE.png">
<meta property="article:published_time" content="2022-12-16T13:47:36.000Z">
<meta property="article:modified_time" content="2023-03-25T05:44:06.263Z">
<meta property="article:author" content="Nexus">
<meta property="article:tag" content="ComputerSystem">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/mbr.png">

<link rel="canonical" href="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机是怎样跑起来的-linux0.11源代码学习 | Meta Field</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
  
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/NexusXDlbh" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <script type="text/javascript">
      console.log(window.location);
      </script>

      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Meta Field</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/NexusXDlbh" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/arch.png">
      <meta itemprop="name" content="Nexus">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meta Field">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机是怎样跑起来的-linux0.11源代码学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-16 21:47:36" itemprop="dateCreated datePublished" datetime="2022-12-16T21:47:36+08:00">2022-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-25 13:44:06" itemprop="dateModified" datetime="2023-03-25T13:44:06+08:00">2023-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ComputerSystem/" itemprop="url" rel="index"><span itemprop="name">ComputerSystem</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>54k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>49 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex" xmlns="http://www.w3.org/2000/svg" width="17.142ex" height="2.081ex" role="img" focusable="false" viewbox="0 -716 7576.6 920"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mi" transform="translate(412,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1290,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mstyle" transform="translate(1793,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mn" transform="translate(2793,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(3570.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mn" transform="translate(4126.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mi" transform="translate(4626.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(5198.6,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g><g data-mml-node="mi" transform="translate(5698.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mn" transform="translate(6131.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mstyle" transform="translate(7131.6,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mo" transform="translate(7298.6,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"/></g></g></g></svg></mjx-container></p>
<p>而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。</p>
<span id="more"></span>
<h1 id="0x00-boot的含义"><a href="#0x00-boot的含义" class="headerlink" title="0x00 boot的含义"></a>0x00 boot的含义</h1><p>先问一个问题，”启动”用英语怎么说？</p>
<p>回答是：boot。可是，boot原来的意思是靴子，”启动”与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：”pull oneself up by one’s bootstraps”</p>
<p>字面意思是”<strong>拽着鞋带把自己拉起来</strong>“，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>
<p>早期真的是这样，<strong>必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。</strong>所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。</p>
<p>计算机的整个启动过程分成 [四个阶段] 。</p>
<h1 id="0x01-BIOS"><a href="#0x01-BIOS" class="headerlink" title="0x01 BIOS"></a>0x01 BIOS</h1><p>为了把一小段程序装入内存，ROM(<strong>R</strong>ead-<strong>O</strong>nly <strong>M</strong>emory)被发明，在ROM上的启动阶段也叫<strong>ROM Stage</strong>，在这个阶段 [<strong>没有内存</strong>] ，需要在 [<strong>ROM</strong>] 上运行代码。这时因为没有内存，没有C语言运行需要的栈空间，开始往往是<strong>汇编语言直接在ROM上运行</strong>，所以<strong>ROM Stage</strong>也是最困难的阶段。计算机通电后，第一件事情就是读取在ROM里<strong>提前</strong>写好的汇编程序，这段程序就叫<strong>BIOS</strong>。</p>
<p>CPU运行于 <strong>[实模式]</strong> 工作环境中，数据位宽为16位，最大物理地址寻址范围是1MB，现在你按下了电源的开机键发电源信号：给CPU加电！BIOS在CPU硬件加电瞬间<strong>强行</strong>将CS值置为<code>0xFFFF</code>，IP的值置为<code>0x0000</code>，这样<strong>CS:IP</strong>就指向<strong>0xFFFF0</strong>这个地址位置，CPU跳到 <strong>0xFFFF0</strong> 处执行程序，一般情况下这里是一条跳转指令，CPU根据这个跳转指令跳到<strong>真正的BIOS入口地址</strong>执行，BIOS就开始做下面的事。</p>
<h2 id="step1-加电自检"><a href="#step1-加电自检" class="headerlink" title="step1 加电自检"></a>step1 加电自检</h2><p>1.<strong>加电自检</strong>(POST,<strong>P</strong>ower <strong>O</strong>n <strong>S</strong>elf <strong>T</strong>est)，检测 [关键设备] 是否正常工作，如果有故障，喇叭就会叫唤。</p>
<p>2.初始化 [显示设备] 并显示显卡信息。</p>
<p>3.检测 [CPU和内存] 并显示检测结果。</p>
<p>4.检测 [标准设备]，如硬盘、光驱、串口设备、并口设备等。</p>
<p>5.检测 [即插即用设备]，并为这些设备分配 <strong>中断号、I/O端口和DMA通道</strong> 等资源。</p>
<p>6.如果硬件配置发生变化，那么这些变化的配置将更新到 CMOS 中。</p>
<h2 id="step2-启动顺序"><a href="#step2-启动顺序" class="headerlink" title="step2 启动顺序"></a>step2 启动顺序</h2><p>7.根据配置的<strong>启动顺序</strong>引导设备启动，通过BIOS中断将设备的引导程序读入内存。</p>
<blockquote>
<p>注👋BIOS中断可以理解为BIOS系统为用户提供的一些封装好了的“API”而已，它之所以也被叫中断，原因在于这部分“API”的运转模式是采用的“中断机制”：中断向量+中断服务程序，也叫<strong>软中断</strong>。</p>
</blockquote>
<p>8.将处理器的控制权交给引导程序，最终引导进入操作系统。</p>
<p>到此处CPU已经 [初始化] 并 [指向BIOS]，下一步要做的：<strong>BIOS读取MBR</strong>。</p>
<h1 id="0x02-主引导记录-MBR"><a href="#0x02-主引导记录-MBR" class="headerlink" title="0x02 主引导记录(MBR)"></a>0x02 主引导记录(MBR)</h1><p><strong>主引导记录</strong>（Master Boot Record，缩写：MBR），又叫做<strong>主引导扇区</strong>，是计算机开机后访问硬盘时所必须要读取的<strong>首个扇区</strong>，它在硬盘上的三维地址（也叫3D参数）为（柱面<strong>C</strong>ylinders，磁头<strong>H</strong>eaders，扇区<strong>S</strong>ectors）＝（0,0,1）。主引导扇区记录着<strong>硬盘本身</strong>的相关信息以及<strong>硬盘各个分区的大小及位置信息</strong>，是数据信息的重要入口，<strong>它告诉CPU到硬盘的哪个位置去寻找操作系统。</strong></p>
<p>BIOS按照”启动顺序”，把控制权转交给排在第一位的硬盘。</p>
<p>这时，<strong>BIOS</strong>读取该硬盘的第一个扇区（主引导扇区），也就是读取<strong>最前面的512个字节</strong>。如果这512个字节的最后两个字节是<strong>0x55</strong>和<strong>0xAA</strong>，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p>
<p>👋对于硬盘而言，一个扇区可能的字节数为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="22.116ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9775.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"/></g><g data-mml-node="mo" transform="translate(1722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msup" transform="translate(2722.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(3729.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4118.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4996.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(6052.3,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(6552.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(6996.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7496.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(7941.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(8441.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(8886.3,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(9386.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。大多数情况下取2，即一个扇区（sector）的大小为512字节。</p>
<p>在使用“主引导记录”（MBR）这个术语的时候，需要根据具体情况判断其到底是指<strong>整个主引导扇区</strong>，还是<strong>主引导扇区的前446字节</strong>。</p>
<blockquote>
<p>The MBR is stored on the first sector of the hard disk and is created along with the first partition on the drive. <strong>It is loaded into memory as one of the first actions during system start up.</strong> </p>
<p><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/topics/computer-science/master-boot-record">Master Boot Record</a> </p>
<p>David Day, in <a target="_blank" rel="noopener" href="https://www.sciencedirect.com/book/9780128007433/cyber-crime-and-cyber-terrorism-investigators-handbook">Cyber Crime and Cyber Terrorism Investigator’s Handbook</a>, 2014</p>
</blockquote>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/mbr.png"></p>
<h2 id="2-1-MBR结构"><a href="#2-1-MBR结构" class="headerlink" title="2.1 MBR结构"></a>2.1 MBR结构</h2><h3 id="2-1-1启动代码（调用OS的机器码）"><a href="#2-1-1启动代码（调用OS的机器码）" class="headerlink" title="2.1.1启动代码（调用OS的机器码）"></a>2.1.1启动代码（调用OS的机器码）</h3><p><code>linux0.11</code>最开始的代码<code>bootsect.s</code>编译为二进制文件后存放在启动区第一扇区（MBR），然后由BIOS搬运至内存的<code>0x7c00</code>位置，CPU也从此处开始不断往后一条一条指令执行。下面贴一小段<a target="_blank" rel="noopener" href="https://github.com/karottc/linux-0.11/blob/master/boot/bootsect.s">源代码</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SETUPLEN = 4				! nr of setup-sectors</span><br><span class="line">BOOTSEG  = 0x07c0			! original address of boot-sector</span><br><span class="line">INITSEG  = 0x9000			! we move boot here - out of the way</span><br><span class="line">SETUPSEG = 0x9020			! setup starts here</span><br><span class="line">SYSSEG   = 0x1000			! system loaded at 0x10000 (65536).</span><br><span class="line">ENDSEG   = SYSSEG + SYSSIZE		! where to stop loading</span><br><span class="line"></span><br><span class="line">! ROOT_DEV:	0x000 - same type of floppy as boot.</span><br><span class="line">!		0x301 - first partition on first drive etc</span><br><span class="line">ROOT_DEV = 0x306</span><br><span class="line"></span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">	mov	ax,#BOOTSEG</span><br><span class="line">	mov	ds,ax</span><br><span class="line">	mov	ax,#INITSEG</span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	cx,#256</span><br><span class="line">	sub	si,si</span><br><span class="line">	sub	di,di</span><br><span class="line">	rep</span><br><span class="line">	movw</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2分区表-Partition-Table"><a href="#2-1-2分区表-Partition-Table" class="headerlink" title="2.1.2分区表(Partition Table)"></a>2.1.2分区表(Partition Table)</h3><p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多划分<strong>四个</strong>一级分区，又叫做<strong>“主分区”</strong>。一个主分区的扇区总数最多不超过<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewbox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g></g></g></g></g></svg></mjx-container>。</p>
<h3 id="2-1-3主引导记录签名"><a href="#2-1-3主引导记录签名" class="headerlink" title="2.1.3主引导记录签名"></a>2.1.3主引导记录签名</h3><p>系统在对硬盘做初始化时写入的一个标签，它是MBR不可或缺的一个组成部分。系统依靠这个签名来识别硬盘，如果硬盘的签名丢失，系统就会认为该硬盘没有初始化。<strong>0x55</strong>和<strong>0xAA</strong>就是签名。</p>
<p>现在BIOS已经把MBR的512字节都装入内存了，执行完BIOS整个代码后，要做的事情是：将控制权交给硬盘的某个分区。</p>
<h2 id="2-2-linux-0-11源码讲解"><a href="#2-2-linux-0-11源码讲解" class="headerlink" title="2.2 linux_0.11源码讲解"></a>2.2 linux_0.11源码讲解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">	mov	ax,#BOOTSEG</span><br><span class="line">	mov	ds,ax</span><br><span class="line">	mov	ax,#INITSEG</span><br><span class="line">	mov	es,ax</span><br></pre></td></tr></table></figure>
<p>硬盘第一扇区也就是MBR加载进入内存后，要将内存地址<code>0x7c00</code>处开始往后512字节的数据原封不动复制到内存的<code>0x90000</code>地址处。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cp.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,#256</span><br><span class="line">sub si,si</span><br><span class="line">sub di,di</span><br><span class="line">rep movw ;重复执行movw指令256次</span><br></pre></td></tr></table></figure>
<p>现在，操作系统最开头的代码，已经被挪到了 <strong>0x90000</strong> 这个位置了。</p>
<p>再往后是一个<strong>跳转</strong>指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jmpi go,0x9000  ;跳转到 0x90000 + go 这个内存地址处执行</span><br><span class="line">go: 			;go标签编译为机器码，是一个值，是go在文件内的偏移地址</span><br><span class="line">  mov ax,cs		;0x90000 + go刚好是这句代码所在的内存地址</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov es,ax</span><br><span class="line">  mov ss,ax</span><br><span class="line">  mov sp,#0xFF00</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/go.png"></p>
<p><strong>数据段寄存器 ds和代码段寄存器 cs</strong> 此时都被设置为了 0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，因为仅仅需要指定偏移地址，方便了跳转和内存访问。</p>
<p>栈顶地址被设置为了 0x9FF00，具体表现为<strong>栈段寄存器 ss</strong> 为 0x9000，<strong>栈基址寄存器 sp</strong> 为 0xFF00。栈是向下发展的，这个栈顶地址 0x9FF00 要远远大于此时代码所在的位置 0x90000，所以栈向下发展就很难撞见代码所在的位置，也就比较安全。</p>
<p>现在在做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下<strong>内存的初步规划</strong>。其中访问代码和访问数据的规划方式就是设置了一个<strong>基址</strong>而已，访问栈就是把<strong>栈顶指针</strong>指向了一个远离代码位置的地方而已。</p>
<p>下面要做的就是把磁盘中其余部分也拿到内存来，即：硬盘载入。</p>
<h1 id="0x03-硬盘载入"><a href="#0x03-硬盘载入" class="headerlink" title="0x03 硬盘载入"></a>0x03 硬盘载入</h1><p>根据分区，讨论3种情况：</p>
<h2 id="3-1-启动管理器-boot-loader"><a href="#3-1-启动管理器-boot-loader" class="headerlink" title="3.1 启动管理器(boot loader)"></a>3.1 启动管理器(boot loader)</h2><p>计算机读取MBR前446字节的机器码后，不再把控制权转交给某一个分区，而是运行事先安装的启动管理器，由用户选择启动哪个OS。Linux环境中，目前最流行的启动管理器是<code>Grub</code>。</p>
<h2 id="3-2-卷引导记录-Volume-boot-record"><a href="#3-2-卷引导记录-Volume-boot-record" class="headerlink" title="3.2 卷引导记录(Volume boot record)"></a>3.2 卷引导记录(Volume boot record)</h2><p>计算机四个主分区里面只有一个是<strong>激活</strong>的，计算机会读取激活分区的第一个扇区，叫做“卷引导记录”(Volume boot record)，缩写为VBR。</p>
<p>VBR主要作用是：告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>
<h2 id="3-3-拓展分区"><a href="#3-3-拓展分区" class="headerlink" title="3.3 拓展分区"></a>3.3 拓展分区</h2><p>很少以拓展分区方式来启动OS。</p>
<p>如果有拓展分区，一般也用<code>boot loader</code>方式启动。</p>
<h2 id="3-4-linux-0-11源码讲解"><a href="#3-4-linux-0-11源码讲解" class="headerlink" title="3.4 linux_0.11源码讲解"></a>3.4 linux_0.11源码讲解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">    mov dx,#0x0000      ; drive 0, head 0</span><br><span class="line">    mov cx,#0x0002      ; sector 2, track 0</span><br><span class="line">    mov bx,#0x0200      ; address = 512, in 0x9000</span><br><span class="line">    mov ax,#0x0200+4    ; service 2, nr of sectors</span><br><span class="line">    int 0x13            ; read it</span><br><span class="line">    jnc ok_load_setup       ; ok - continue</span><br><span class="line">    mov dx,#0x0000</span><br><span class="line">    mov ax,#0x0000      ; reset the diskette</span><br><span class="line">    int 0x13</span><br><span class="line">    jmp load_setup</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><strong>int 0x13</strong>：发起0x13号中断，上面的<strong>通用寄存器ax,bx,cx,dx</strong>都是这个中断指令的参数。</p>
<p>用途：将指定<strong>扇区</strong>的代码加载到<strong>内存</strong>的指定位置，它可以完成磁盘(包括硬盘和软盘)的复位,  读写,  校验,  定位,  诊断,  格式化等功能。int 0x13采用的就是CHS寻址方式（柱面<strong>C</strong>ylinders，磁头<strong>H</strong>eaders，扇区<strong>S</strong>ectors），因此最大识能访问<strong>8 GB</strong>左右的硬盘。</p>
<p>上面代码的作用是：</p>
<p><strong>将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区</strong>。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/in.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ok_load_setup:</span><br><span class="line">    ...</span><br><span class="line">    mov ax,#0x1000</span><br><span class="line">    mov es,ax       ; segment of 0x10000</span><br><span class="line">    call read_it</span><br><span class="line">    ...</span><br><span class="line">    jmpi 0,0x9020</span><br></pre></td></tr></table></figure>
<p>这段代码作用是<strong>把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处</strong>。至此，整个操作系统的<strong>全部代码</strong>，就已经全部从硬盘中，被搬迁到内存来了。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/m1.png"></p>
<p>下面是最后一次折腾内存，我们这部分不用细究代码，知道最后的结果就可以。整个OS的编译过程，是通过<strong>Makefile</strong>和<strong>build.c</strong>配合完成的，最终结果是：</p>
<p><strong><em>1.</em></strong> 把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区。</p>
<p><strong><em>2.</em></strong> 把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。</p>
<p><strong><em>3.</em></strong> 把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/m2.png" style="zoom: 150%;"></p>
<p>下面依次进行：实模式转为保护模式、分页机制，再跳转到内核。</p>
<p>Intel CPU 一般可以在两种模式下运行，即 实模式 和 保护模式。早期的 Intel CPU（8088/8086） 只能工作在实模式下，某一时刻只能运行单个任务。对于 Intel 80386 以上的芯片则还可以运行在 32 位 保护模式下。在保护模式下运行可以支持多任务；支持 4G 的物理内存；支持虚拟内存；支持内存的页式 管理和段式管理；支持特权级。</p>
<p>实模式：8086（微机原理）。后面8086发展到了80286，此时址总线已有24根，但是<strong>在实模式下</strong>，为了向下兼容，系统表现的行为又应同8086一样，即仿佛“只有20根地址总线”。为了能够自由选择<strong>实模式下</strong>寻址能力的大小，便出现了A20 Gate。</p>
<p>A20 Gate是第21根地址总线，它有一个开关，<strong>保护模式下打开</strong>，突破地址信号线 20 位的宽度，变成 32 位可用。</p>
<p>为了从实模式转为保护模式，OS设置全局描述符表<strong>GDT</strong>。段值存入段寄存器，而该值作为索引，用于在<strong>GDT</strong>（<strong>G</strong>lobal <strong>D</strong>escriptor <strong>T</strong>able）中寻找到对应的一个表项（段描述符），该表项中含有段地址、段大小、访问控制等信息，得到其中的段地址后再加上合法的段内偏移，即可访问到对应的物理地址。</p>
<p>总结就是：保护模式下寻址方式为</p>
<script type="math/tex; mode=display">
物理地址 = GDT对应表项中的段地址 + 合法偏移地址</script><p><strong>GDT的本质就是个规定好格式的数据结构而已。</strong></p>
<p>✍GDT存在的意义：</p>
<blockquote>
<p><strong>全局描述符表GDT（Global Descriptor Table）</strong>在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者提供了一个<strong>寄存器GDTR</strong>用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过<strong>LGDT指令</strong>将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。</p>
<p>80286之前处理器只有实模式，GDT是提供内存保护，限制非法访问内存的一种方式。</p>
</blockquote>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/seg.png"></p>
<p>保护模式下，物理地址并不是直接暴露在程序员面前了，寻址有了更多的检查步骤，这是属于虚拟内存的范畴了，在此就不再深入。</p>
<p>此时内存是这样：</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/gdtm.png"></p>
<p>其中GDTR寄存器存储了GDT结构，即：<strong>GDT description structure</strong></p>
<p>GDT description structure描述了GDT的位置及大小（并非GDT的一部分）。</p>
<p>可通过LGDTR指令从内存中往GDTR中加载GDT description structure。</p>
<p>GDTR、IDTR、TR、LDTR都是<strong>内存管理寄存器</strong>。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/gdtr.png" alt></p>
<blockquote>
<p>GDTR：存放全局描述符表GDT的线性基地址和表长度。处理器加电或复位后，基地址默认为0，表长度默认为0xFFFF; 在保护模式初始化过程中，必须给GDTR加载一个新值。</p>
<p>IDTR：存放中断描述符表IDT的线性基地址和表长度。处理器加电或复位后，基地址默认为0，表长度默认为0xFFFF。</p>
</blockquote>
<p>首先配置全局描述符表 gdt 和中断描述符表 idt：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lidt  idt_48</span><br><span class="line">lgdt  gdt_48</span><br></pre></td></tr></table></figure>
<p>现在的代码仍然是setup.s中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,#0xD1        ; command write</span><br><span class="line">out #0x64,al</span><br><span class="line">mov al,#0xDF        ; A20 on</span><br><span class="line">out #0x60,al</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是，<strong>打开 A20 地址线</strong>，进入保护模式。</p>
<p>下面有一大坨是专门对8259芯片的编程，微机原理讲过8259，去复习一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; well, that went ok, I hope. Now we have to reprogram the interrupts :-(</span><br><span class="line">; we put them right after the intel-reserved hardware interrupts, at</span><br><span class="line">; int 0x20-0x2F. There they won't mess up anything. Sadly IBM really</span><br><span class="line">; messed this up with the original PC, and they haven't been able to</span><br><span class="line">; rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,</span><br><span class="line">; which is used for the internal hardware interrupts as well. We just</span><br><span class="line">; have to reprogram the 8259's, and it isn't fun.</span><br><span class="line"></span><br><span class="line">    mov al,#0x11        ; initialization sequence</span><br><span class="line">    out #0x20,al        ; send it to 8259A-1</span><br><span class="line">    .word   0x00eb,0x00eb       ; jmp $+2, jmp $+2</span><br><span class="line">    out #0xA0,al        ; and to 8259A-2</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x20        ; start of hardware int's (0x20)</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x28        ; start of hardware int's 2 (0x28)</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x04        ; 8259-1 is master</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x02        ; 8259-2 is slave</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x01        ; 8086 mode for both</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0xFF        ; mask off all interrupts for now</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    out #0xA1,al</span><br></pre></td></tr></table></figure>
<p>对于上面这段程序的解读，请教了CXQ老师：</p>
<blockquote>
<p>JMP SHORT $+2 指令的机器码是  00EBH  。<br>       功能：跳转到顺序的下一条指令。<br>       作用：清空指令预取队列、延时。<br>       现代快速CPU初始化慢速接口时，两个动作之间要加延时，这个JMP指令比NOP指令的延时时间更长（因为会清空指令队列）。还有一个原因，清空指令队列，也可以防止CPU乱序执行指令，而写8259初始化命令字是有严格顺序的。</p>
<p>代码中的.word语句相当于<strong>直接用机器码写程序</strong>。</p>
</blockquote>
<p>接下来的一步，就是<strong>真正切换模式</strong>的一步了，从代码上看就两行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0001  ; protected mode (PE) bit</span><br><span class="line">lmsw ax      ; This is it;</span><br><span class="line">jmpi 0,8     ; jmp offset 0 of segment 8 (cs)</span><br></pre></td></tr></table></figure>
<p>前两行，将 cr0 这个寄存器的位 0 置 1，模式就从<strong>实模式切换到保护模式</strong>了。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/z1.png" alt></p>
<p>跳转指令 <strong>jmpi</strong>，后面的 8 表示 cs（代码段寄存器）的值，0 表示偏移地址。请注意，此时已经是保护模式了，之前也说过，保护模式下内存寻址方式变了，<strong>段寄存器里的值被当做段选择子</strong>。</p>
<p>8 用二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000,0000,0000,1000</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/dxzz.png" alt></p>
<p>可以知道<strong>描述符索引值是 1</strong>，也就是要去<strong>全局描述符表（gdt）</strong>中找第1项段描述符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    .word   0,0,0,0     ; dummy</span><br><span class="line"></span><br><span class="line">    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    .word   0x0000      ; base address=0</span><br><span class="line">    .word   0x9A00      ; code read/exec</span><br><span class="line">    .word   0x00C0      ; granularity=4096, 386</span><br><span class="line"></span><br><span class="line">    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    .word   0x0000      ; base address=0</span><br><span class="line">    .word   0x9200      ; data read/write</span><br><span class="line">    .word   0x00C0      ; granularity=4096, 386</span><br></pre></td></tr></table></figure>
<p>第 0 项是空值，第一项被表示为<strong>代码段描述符</strong>，是个可读可执行的段，第二项为<strong>数据段描述符</strong>，是个可读可写段，不过他们的<strong>段基址都是 0。</strong></p>
<p>所以，这里取的就是这个代码段描述符，<strong>段基址是 0</strong>，偏移也是 0，那加一块就还是 0 咯，所以最终这个跳转指令，就是跳转到内存地址的 0 地址处，开始执行。</p>
<p>0地址处就是操作系统全部代码的 system 这个大模块，system 模块怎么生成的呢？由 Makefile 文件可知，是由 head.s 和 main.c 以及其余各模块的操作系统代码编译并链接在一起而成的，可以理解为操作系统的全部核心代码编译后的结果。启动模块最后还剩一个文件，它是正式进入c语言<code>main.c</code>前的汇编文件：header.s，文件比较短。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:	;表示页目录，后续设置分页机制时，页目录存放此处并覆盖原有代码</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov fs,ax ;fs是标志段寄存器</span><br><span class="line">    mov gs,ax ;fs是全局段寄存器</span><br><span class="line">    ;段寄存器赋值为 0x10，根据段描述符结构解析，表示这几个段寄存器的值为指向全局描述符表中的第二个段描述符，也就是数据段描述符。</span><br><span class="line">    lss esp,_stack_start ;让 ss:esp 这个栈顶指针指向了 _stack_start 这个标号的位置，0x9FF00</span><br></pre></td></tr></table></figure>
<p>👋拓展：段寄存器的诞生</p>
<blockquote>
<p>段寄存器的产生源于Intel 8086 CPU体系结构中<strong>数据总线</strong>与<strong>地址总线</strong>的宽度不一致。数据总线的宽度，即ALU(算数逻辑单元)的宽度，平常说一个CPU是“16位”或者“32位”指的就是ALU的宽度。</p>
<p>地址总线的宽度不一定要与ALU的宽度相同。因为ALU的宽度是固定的，它受限于当时的工艺水平，当时只能制造出16位的ALU；但地址总线不一样，它可以设计得更宽。8086中数据总线16位，地址总线20位，地址总线宽度大于数据总线会带来一些麻烦，<strong>ALU无法在单个指令周期里完成对地址数据的运算。</strong>有一些容易想到的可行的办法，比如定义一个新的寄存器专门用于存放地址的高4位，但这样增加了计算的复杂性，程序员要增加成倍的汇编代码来操作地址数据而且无法保持兼容性。</p>
<p>Intel想到了一个折中的办法：把内存分段，并设计了4个段寄存器，CS(Code Segment)，DS(Data Segment)，SS(Stack Segment)，ES(Extra Segment)，把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。</p>
<p>这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，才共同构成完整的物理地址。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   call setup_idt ;设置 [中断描述符表]</span><br><span class="line">call setup_gdt ;设置 [全局描述符表]</span><br><span class="line">   mov eax,10h</span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov gs,ax</span><br><span class="line">   lss esp,_stack_start</span><br></pre></td></tr></table></figure>
<p>中断描述符表 <strong>idt</strong> 里面存储着一个个中断描述符，每一个中断号就对应着一个中断描述符（一一映射），而中断描述符里面存储着主要是中断程序的地址，这样一个中断号过来后，CPU 就会自动寻找相应的中断程序，然后去执行它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setup_idt:</span><br><span class="line">    lea edx,ignore_int</span><br><span class="line">    mov eax,00080000h</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,8E00h</span><br><span class="line">    lea edi,_idt</span><br><span class="line">    mov ecx,256</span><br><span class="line">rp_sidt:</span><br><span class="line">    mov [edi],eax</span><br><span class="line">    mov [edi+4],edx</span><br><span class="line">    add edi,8</span><br><span class="line">    dec ecx</span><br><span class="line">    jne rp_sidt</span><br><span class="line">    lidt fword ptr idt_descr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">idt_descr:</span><br><span class="line">    dw 256*8-1</span><br><span class="line">    dd _idt</span><br><span class="line"></span><br><span class="line">_idt:</span><br><span class="line">    DQ 256 dup(0)</span><br></pre></td></tr></table></figure>
<p>这段程序的作用就是，<strong>设置了 256 个中断描述符</strong>，并且让每一个中断描述符中的中断程序例程都指向一个 <strong>ignore_int</strong> 的函数地址，这个是个<strong>默认的中断处理程序</strong>，之后会逐渐被各个具体的中断程序所覆盖。比如之后键盘模块会将自己的键盘中断处理程序，覆盖过去。现在，产生任何中断都会指向这个默认的函数 ignore_int，也就是说现在这个阶段<strong>你按键盘还不好使</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;设置好的GDT</span><br><span class="line">_gdt:</span><br><span class="line">    DQ 0000000000000000h    ;/* NULL descriptor */</span><br><span class="line">    DQ 00c09a0000000fffh    ;/* 16Mb */</span><br><span class="line">    DQ 00c0920000000fffh    ;/* 16Mb */</span><br><span class="line">    DQ 0000000000000000h    ;/* TEMPORARY - don't use */</span><br><span class="line">    DQ 252 dup(0)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/gdt.png" alt></p>
<p>原来已经设置过一遍了，这里又要重新设置一遍，因为原来设置的 gdt 是在 setup 程序中，之后这个地方要被缓冲区覆盖掉，所以这里重新设置在 head 程序中，这块内存区域之后就不会被其他程序用到并且覆盖了。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/f.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;开启分页机制，并且跳转到 main 函数</span><br><span class="line">jmp after_page_tables</span><br><span class="line">...</span><br><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main ;main函数地址压栈</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">    jmp L6</span><br></pre></td></tr></table></figure>
<p>开启分页机制，并跳转到main函数</p>
<blockquote>
<p>In fact, segmentation and paging are somewhat redundant since both can be used to separate the physical address spaces of processes : </p>
<p><strong>segmentation</strong> can assign a different linear address space to each process, while <strong>paging</strong> can map the same linear address space into different physical address spaces.</p>
</blockquote>
<p>✍虚拟内存、分页与分段机制</p>
<p>这三个技术出现的目的：管理好计算机的<strong>内存</strong></p>
<p>早期的计算机是直接使用实际的内存地址的，但是面临3个问题：</p>
<p><u>①内存使用效率低</u></p>
<p>很多情况下，有大量的数据都在<strong>装入装出内存</strong>，效率低下。</p>
<p><u>②进程地址空间不隔离</u></p>
<p>程序直接访问物理内存，恶意程序可以随意修改其它进程的内存数据，达到破坏目的；非恶意程序会导致计算机运行异常。</p>
<p><u>③程序运行地址不确定</u></p>
<p>当内存中剩余空间可以满足程序的要求后，OS会在剩余空间中<strong>随机</strong>分配一段连续的地址空间给程序使用。</p>
<p>为了解决上述问题，人们想到一种方法：增加一个<strong>中间层</strong>，利用一种间接的地址访问方法访问物理内存，按照这种方法，程序中访问的内存地址不再是实际物理内存地址，而是虚拟地址，然后由操作系统将这个虚拟地址映射到对应的物理内存地址上，只要处理好虚拟地址到内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同区域，达到内存地址空间隔离的效果。</p>
<p>怎样实现映射机制？人们想到分段（<strong>Segmentation</strong>）</p>
<p>Segmentation是虚拟地址空间和内存空间做<strong>一一映射</strong>，是一种线性地址映射，和高中学的内容很像，对吧？</p>
<p>分段只解决了进程地址不隔离和进程地址随机这2个问题，内存的效率问题没有得到解决，为了把内存效率问题解决，人们想到使用粒度更小的内存分割与映射方法，即：分页<strong>Paging</strong></p>
<p>分页的基本方法是，将地址空间分成许多的页。每页的大小由CPU决定，然后由操作系统选择页的大小。目前Inter系列的CPU支持 4KB 或 4MB 的页大小，而PC上目前都选择使用 4KB 。</p>
<p>分页的思想是：程序运行时用到哪页，就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</p>
<p>分段机制目的：为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。</p>
<p>分页机制目的：可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。</p>
<blockquote>
<p>在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它<strong>必须</strong>存在，而分页机制是可以选择开启或关闭的。</p>
<p>所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。</p>
</blockquote>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/segpage.png" alt></p>
<p>分页地址变换举例：</p>
<p>经过分段机制后的线性地址是：15M，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="12.879ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 5692.7 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mi" transform="translate(1551,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(2587.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(3643.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mi" transform="translate(4933.7,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g></g></g></svg></mjx-container></p>
<p>用二进制表示就是：</p>
<script type="math/tex; mode=display">
0000000011 \_ 1100000000 \_ 000000000000</script><p>CPU看到我们给出的内存地址后，把线性地址拆分为：</p>
<script type="math/tex; mode=display">
高10位：0000000011 \\
中10位：1100000000 \\
低12位：000000000000</script><p>高 10 位负责在<strong>页目录表</strong>中找到一个<strong>页目录项</strong>，这个页目录项的值加上中间 10 位拼接后的地址去<strong>页表</strong>中去寻找一个<strong>页表项</strong>，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。</p>
<p>而这一切的操作，都由计算机的一个硬件叫 <strong>MMU</strong>，中文名字叫<strong>内存管理单元</strong>，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。</p>
<p>作为操作系统这个软件层，只需要提供好<strong>页目录表和页表</strong>即可，这种页表方案叫做<strong>二级页表</strong>，第一级叫<strong>页目录表 PDE</strong>，第二级叫<strong>页表 PTE</strong>。</p>
<p>✍如何开启分页机制？</p>
<p>开启分页机制的开关：cr0寄存器中的31号位（从左往右第1位）写为1即可：</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr.png" alt></p>
<p>这段代码，就是帮我们把页表和页目录表在内存中写好，之后开启 cr0 寄存器的分页开关：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    mov ecx,1024*5</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edi,edi</span><br><span class="line">    pushf</span><br><span class="line">    cld</span><br><span class="line">    rep stosd</span><br><span class="line">    mov eax,_pg_dir ;将页目录表放在内存地址的最开头</span><br><span class="line">    </span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax,00001000h</span><br><span class="line">    jge L3</span><br><span class="line">    popf</span><br><span class="line">    ;设置页表具体数据</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov cr3,eax</span><br><span class="line">    ;告诉CPU的cr3寄存器：0 地址处就是页目录表，再通过页目录表可以找到所有的页表</span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or  eax,80000000h</span><br><span class="line">    mov cr0,eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>linux0.11认为，总共可以使用的内存不超过16M，即：最大地址空间为：<code>0xFFFFFH</code>。</p>
<p>而按照当前的页目录表和页表这种机制，1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），1 个页表最多包含 1024 个页表项（也就是 1024 个页），1 页为 4KB（因为有 12 位偏移地址），因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。</p>
<p><strong>注👋 4K 内存通常叫做 1 页内存</strong></p>
<p>最终将页目录表和页表填写好数值，来覆盖整个 16MB 的内存。随后，开启分页机制。此时内存中的页表相关的布局如下：</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/yb.png" alt></p>
<p>这些页目录表和页表放到了整个内存布局中最开头的位置，就是覆盖了开头的 system 代码了，不过被覆盖的 system 代码已经执行过了，所以无所谓。</p>
<p>👋几个地址：</p>
<p>逻辑地址：程序员写代码开发时候给出的地址，包括 <strong>段选择子</strong> 和 <strong>偏移地址</strong> 两部分。</p>
<p>线性地址：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。</p>
<p>物理地址：真正在内存中的地址</p>
<p>跳到内核中的main：进入<code>main.c</code>这个由C语言写的主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;<span class="comment">//根设备号 -&gt; ROOT_DEV</span></span><br><span class="line">    drive_info = DRIVE_INFO; </span><br><span class="line">    <span class="comment">//此时中断仍然被禁止，做完必要的设置后开启</span></span><br><span class="line">    memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 内存大小=1Mb 字节+扩展内存(k)*1024 字节</span></span><br><span class="line">    memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">    <span class="comment">// 忽略不到 4Kb（1 页）的内存数</span></span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>) </span><br><span class="line">        buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    </span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();	<span class="comment">// 中断初始化</span></span><br><span class="line">    blk_dev_init(); <span class="comment">// 块设备初始化</span></span><br><span class="line">    chr_dev_init(); <span class="comment">// 字符设备初始化</span></span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();	<span class="comment">// 设置开机启动时间Îstartup_time</span></span><br><span class="line">    sched_init();	<span class="comment">// 调度程序初始化(加载了任务 0 的 tr, ldtr)</span></span><br><span class="line">    buffer_init(buffer_memory_end);<span class="comment">// 内存管理初始化(内存链表等)</span></span><br><span class="line">    hd_init(); 		<span class="comment">// 硬盘初始化</span></span><br><span class="line">    floppy_init();	<span class="comment">// 软驱初始化 </span></span><br><span class="line">    sti();	        <span class="comment">// 所有初始化工作都做完了，开启中断</span></span><br><span class="line">    move_to_user_mode();<span class="comment">//切换用户模式</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) { <span class="comment">/* we count on this going ok */</span></span><br><span class="line">        init();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(;;) pause();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>整个操作系统也会最终停留在最后一行死循环中，永不返回，直到关机。</p>
<h2 id="3-5-拓展：x86架构的控制寄存器"><a href="#3-5-拓展：x86架构的控制寄存器" class="headerlink" title="3.5 拓展：x86架构的控制寄存器"></a>3.5 拓展：x86架构的控制寄存器</h2><p>控制寄存器保存自身关键信息，用于<strong>控制和确定处理器的操作模式</strong>以及<strong>当前执行任务</strong>的特性。</p>
<p>32位CPU有CR0-CR4，64位CPU增加了CR8。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr04.png" alt></p>
<h3 id="CR0（尤其重要）"><a href="#CR0（尤其重要）" class="headerlink" title="CR0（尤其重要）"></a>CR0（尤其重要）</h3><p>存储了CPU控制标记和工作状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bit</th>
<th>Label</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>PE</strong></td>
<td><strong>Protected Mode Enable（是否开启保护模式）</strong></td>
</tr>
<tr>
<td>1</td>
<td>MP</td>
<td>Monitor co-processor（控制与设定了TS标志的WAIT（或FWAIT）指令的的交互）</td>
</tr>
<tr>
<td>2</td>
<td>EM</td>
<td>x87 FPU Emulation（标示处理器是否有x87 FPU）</td>
</tr>
<tr>
<td>3</td>
<td>TS</td>
<td>Task switched（当执行一个新任务时，直到x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4指令执行完才保存其上下文）</td>
</tr>
<tr>
<td>4</td>
<td>ET</td>
<td>Extension type（是否支持Intel 387 DX math coprocessor指令）</td>
</tr>
<tr>
<td>5</td>
<td>NE</td>
<td>Numeric error（是否开启x87 FPU错误报告机制）</td>
</tr>
<tr>
<td>16</td>
<td>WP</td>
<td>Write protect（是否开启内存写保护）</td>
</tr>
<tr>
<td>18</td>
<td>AM</td>
<td>Alignment mask（是否启用内存对齐自动检查）</td>
</tr>
<tr>
<td>29</td>
<td>NW</td>
<td>Not-write through（控制当写操作命中缓冲的行为）</td>
</tr>
<tr>
<td>30</td>
<td>CD</td>
<td>Cache disable</td>
</tr>
<tr>
<td><strong>31</strong></td>
<td><strong>PG</strong></td>
<td><strong>Paging（是否启用内存分页）</strong></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr0.png" alt></p>
<h3 id="CR1（未使用）"><a href="#CR1（未使用）" class="headerlink" title="CR1（未使用）"></a>CR1（未使用）</h3><h3 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h3><p>存储引起缺页的线性地址。(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="13.472ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 5954.4 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1280,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1757,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(2445.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3445.4,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mi" transform="translate(4194.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(4723.4,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(5295.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(5593.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g></svg></mjx-container>线性地址)</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr2.png" alt></p>
<h3 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h3><p>存储了当前进程的虚拟地址空间的重要信息——<strong>页目录</strong>地址，可以说是整个虚拟地址翻译中的顶级指挥棒，在进程空间切换的时候，CR3也将同步切换。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cr3.png" alt></p>
<p>PCD:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="26.214ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 11586.4 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1280,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1757,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(2445.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3445.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(3743.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(4209.4,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(4694.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(5160.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(5458.4,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mi" transform="translate(6218.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(6747.4,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(7180.4,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(7756.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(8222.4,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g><g data-mml-node="mi" transform="translate(9050.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(9395.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(9864.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(10393.4,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(10822.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(11120.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g></g></svg></mjx-container>:控制分页时访问第一个页使用的内存类型。</p>
<p>PCD=1:禁止某个页写入Cache，<strong>直接</strong>写内存。</p>
<p>PWT:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="27.082ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 11970.4 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(1280,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1757,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(2445.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3445.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(3743.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(4209.4,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(4694.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(5160.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(5458.4,0)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g><g data-mml-node="mi" transform="translate(6506.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(6957.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(7302.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(7663.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(8129.4,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mi" transform="translate(8833.4,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(9409.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(9860.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(10345.4,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(10917.4,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(11394.4,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container>:控制分页时访问第一个页使用的内存类型。</p>
<p>PWT=1:写数据到<strong>Cache</strong>的时候<strong>也要</strong>将数据写入<strong>内存</strong>。</p>
<h3 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h3><p>存储了CPU工作相关以及当前人任务的一些信息。</p>
<h3 id="CR8"><a href="#CR8" class="headerlink" title="CR8"></a>CR8</h3><p>64位新增拓展使用，用于读写Task Priority Register(TPR)，它指定了<strong>外部中断生效的优先级阈值</strong>。CR8只对Intel 64架构可用。</p>
<h1 id="0x04-OS内核载入"><a href="#0x04-OS内核载入" class="headerlink" title="0x04 OS内核载入"></a>0x04 OS内核载入</h1><p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/lc.png" alt></p>
<p>大致过程如下：</p>
<blockquote>
<p>控制权转交给操作系统后，操作系统的内核首先被载入内存。以Linux系统为例，先载入<code>/boot</code>目录下面的<strong>kernel</strong>。内核加载成功后，第一个运行的程序是<code>/sbin/init</code>。它根据配置文件（Debian系统是<code>/etc/initab</code>）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行<code>/bin/login</code>程序，跳出登录界面，等待用户输入用户名和密码。至此，全部启动过程完成。</p>
<p>摘自 阮一峰的博客</p>
</blockquote>
<p>目前的内存布局图：</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/memory.png" alt></p>
<p>系统在执行完 <code>boot/</code>目录中的 <code>head.s</code> 程序后就将 执行权交给了 <code>main.c</code>。该程序虽然不长，但却包括了内核初始化的所有工作。因此在阅读该程序的代码时 需要参照很多其它程序中的初始化部分。</p>
<p><code>main.c</code>主要分为四大部分：</p>
<p>①一些参数的取值和计算</p>
<p>②各种初始化</p>
<p>③切换到用户态模式，并在一个新的进程中做一个最终的初始化 init</p>
<p>④死循环</p>
<p>下面分模块品读linux0.11源码：</p>
<h2 id="1-参数取值与计算"><a href="#1-参数取值与计算" class="headerlink" title="1.参数取值与计算"></a>1.参数取值与计算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">	ROOT_DEV = ORIG_ROOT_DEV; <span class="comment">//系统根文件设备号</span></span><br><span class="line">    drive_info = DRIVE_INFO; <span class="comment">//存储在内存0x90000处设备信息</span></span><br><span class="line">    ···</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>下面分析下面的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">    memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>) </span><br><span class="line">        buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>上面这段代码做的事：计算3个变量</p>
<p><code>main_memory_start</code></p>
<p><code>buffer_memory_end</code></p>
<p><code>memory_end</code></p>
<p>这么多代码，判断的标准都是<code>memory_end</code>，其实就是根据内存大小设置不同边界值。假设内存共8M，那么memory_end就是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="15.712ex" height="1.581ex" role="img" focusable="false" viewbox="0 -677 6944.9 699"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mn" transform="translate(1722.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/></g><g data-mml-node="mo" transform="translate(3944.7,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mn" transform="translate(4944.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/></g></g></g></svg></mjx-container>，根据上面的逻辑算出buffer_memory_end为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="15.712ex" height="1.581ex" role="img" focusable="false" viewbox="0 -677 6944.9 699"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mn" transform="translate(1722.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/></g><g data-mml-node="mo" transform="translate(3944.7,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mn" transform="translate(4944.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/></g></g></g></svg></mjx-container>，最后把buffer_memory_end的值赋给main_memory_start，将两块内存衔接在一起，图如下：</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/memdis.png" alt></p>
<h2 id="2-各种初始化"><a href="#2-各种初始化" class="headerlink" title="2.各种初始化"></a>2.各种初始化</h2><h3 id="（1）主内存区管理分配-mem-init"><a href="#（1）主内存区管理分配-mem-init" class="headerlink" title="（1）主内存区管理分配 mem_init"></a>（1）主内存区管理分配 mem_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start, memory_end);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>mem_init函数源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOW_MEM 0x100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGING_MEMORY (15*1024*1024)</span></span><br><span class="line"><span class="comment">//15MB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span></span><br><span class="line"><span class="comment">//右移12位是把偏移地址弄走,处理后每个元素都代表一个4K内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USED 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> HIGH_MEMORY = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> mem_map[PAGING_PAGES] = { <span class="number">0</span>, };</span><br><span class="line"></span><br><span class="line"><span class="comment">// start_mem = 2 * 1024 * 1024</span></span><br><span class="line"><span class="comment">// end_mem = 8 * 1024 * 1024</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">long</span> start_mem, <span class="type">long</span> end_mem)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HIGH_MEMORY = end_mem;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line">        mem_map[i] = USED;<span class="comment">//内存被占用</span></span><br><span class="line">    i = MAP_NR(start_mem);</span><br><span class="line">    end_mem -= start_mem;</span><br><span class="line">    end_mem &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">while</span> (end_mem--&gt;<span class="number">0</span>)</span><br><span class="line">        mem_map[i++]=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>所谓的内存管理，就是准备了一张表，记录哪些内存被占用，哪些没有被占用。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/meminit.png" alt></p>
<p>1M 以下的内存这个数组干脆没有记录，这里的内存是无需管理的，或者换个说法是无权管理的，也就是没有权利申请和释放，因为这个区域是内核代码所在的地方，不能被“污染”。</p>
<p>1M 到 2M 这个区间是<strong>缓冲区</strong>，2M 是缓冲区的末端，缓冲区的开始在哪里之后再说，这些地方不是主内存区域，因此直接标记为 USED，产生的效果就是无法再被分配了。</p>
<p>2M 以上的空间是<strong>主内存区域</strong>，而主内存目前没有任何程序申请，所以初始化时统统都是零，未来等着应用程序去申请和释放这里的内存资源。</p>
<h3 id="（2）中断初始化-trap-init"><a href="#（2）中断初始化-trap-init" class="headerlink" title="（2）中断初始化 trap_init"></a>（2）中断初始化 trap_init</h3><p>中断部分讲解以键盘为例：键盘的本质是I/O接口。按下键盘后会触发中断，CPU接收到中断后，根据中断号寻找由OS写好的键盘中断处理程序。键盘驱动才是真正意义上的中断：硬中断，是由硬件实实在在发起的中断。</p>
<p>我们为某一设备<strong>建立中断机制</strong>的标准流程：</p>
<p>​    1.初始化8259</p>
<p>​    2.建立IDT表（中断描述符表）</p>
<p>​    3.编写中断服务程序</p>
<p>我们以 <strong>Linux 0.11</strong> 源码为例，发现进入内核的 main 函数后不久，有这样一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码作用：设置中断表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="comment">//set_xxx_gate最终的效果是：在中断描述符表中插入了一个中断描述符</span></span><br><span class="line">    set_trap_gate(<span class="number">0</span>,&amp;divide_error);</span><br><span class="line">    <span class="comment">//设置0号中断，对应中断处理程序是divide_error(除法异常)</span></span><br><span class="line">    set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">    set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">    set_system_gate(<span class="number">3</span>,&amp;int3);   <span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">    set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">    set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">    <span class="comment">//5号边界中断</span></span><br><span class="line">    set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">    set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">    set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">    set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">    set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">    set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">    set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">    set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">    set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">    set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    <span class="comment">//17 到 48 号中断都批量设置为了 reserved 函数，这是暂时的</span></span><br><span class="line">    <span class="comment">//后面各个硬件初始化时要重新设置好这些中断，把暂时的这个给覆盖掉</span></span><br><span class="line">    <span class="comment">//此时留个印象就行</span></span><br><span class="line">    set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">    set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>键盘产生的中断的中断号是 <strong>0x21</strong>，此时这个中断号还仅仅对应着一个临时的中断处理程序 &amp;reserved，我们接着往后看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">    sti();</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">con_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>trap_init 后有个 <strong>tty_init</strong>，最后根据调用链，会调用到一行添加 <strong>0x21</strong> 号中断处理程序的代码，就是刚刚熟悉的 <strong>set_trap_gate</strong>，而后面的 <strong>keyboard_interrupt</strong> 根据名字也可以猜出，就是键盘的中断处理程序，从这行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);</span><br></pre></td></tr></table></figure>
<p>开始，我们的键盘开始生效，但是现在中断处于禁用状态，所有中断都不好使。</p>
<p>我们注意到<code>sti();</code>，最终对应一个同名的汇编指令<code>sti</code>，表示<strong>允许中断</strong>。</p>
<p>然后中断才允许使用，键盘开始生效！</p>
<h3 id="（3）块设备请求项初始化-blk-dev-init"><a href="#（3）块设备请求项初始化-blk-dev-init" class="headerlink" title="（3）块设备请求项初始化 blk_dev_init"></a>（3）块设备请求项初始化 blk_dev_init</h3><p>读取硬盘中的数据到内存，是OS的基础功能。</p>
<p>读取硬盘需要有<strong>块设备驱动程序</strong>，如果以文件形式读取还要有一层文件系统。</p>
<p><strong>块设备请求项的初始化</strong>，是读取 块设备 与 内存缓冲区 之间的桥梁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blk_dev_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) {</span><br><span class="line">        request[i].dev = <span class="number">-1</span>;</span><br><span class="line">        request[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>易知，对<code>dev</code> 和<code>next</code>分别赋值为-1和NULL就是初始化，没有任何作用，下面我们看一下<code>request</code>的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, this is an expanded form so that we can use the same</span></span><br><span class="line"><span class="comment"> * request for paging requests when that is implemented. In</span></span><br><span class="line"><span class="comment"> * paging, 'bh' is NULL, and 'waiting' is used to wait for</span></span><br><span class="line"><span class="comment"> * read/write completion.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> {</span></span><br><span class="line">    <span class="type">int</span> dev;        <span class="comment">/* -1 if no request */</span></span><br><span class="line">    <span class="type">int</span> cmd;        <span class="comment">/* READ or WRITE */</span></span><br><span class="line">    <span class="type">int</span> errors;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sector;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_sectors;</span><br><span class="line">    <span class="type">char</span> * buffer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>对<code>request</code>结构体的解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> {</span></span><br><span class="line">    <span class="type">int</span> dev;        				<span class="comment">//设备号,-1表示空闲</span></span><br><span class="line">    <span class="type">int</span> cmd;        				<span class="comment">//命令</span></span><br><span class="line">    <span class="type">int</span> errors;						<span class="comment">//错误次数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sector;			<span class="comment">//起始磁盘扇区</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_sectors;		<span class="comment">//扇区数量</span></span><br><span class="line">    <span class="type">char</span> * buffer;					<span class="comment">//数据缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span>	<span class="comment">//进程 或 哪个进程发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span>		<span class="comment">//缓冲区头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span>			<span class="comment">//指向下一个请求项	</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//举例简单理解</span></span><br><span class="line">request:</span><br><span class="line">	什么设备：硬盘</span><br><span class="line">    什么操作：读</span><br><span class="line">    从哪里读：<span class="number">2</span><span class="number">-5</span>扇区</span><br><span class="line">    读到哪里：内存<span class="number">0x90000</span></span><br></pre></td></tr></table></figure>
<p>所以上面的代码完成以下工作：</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/request.png" alt></p>
<p><code>request[32]</code>数组后面读磁盘会具体阐释。</p>
<h3 id="（4）控制台初始化-tty-init"><a href="#（4）控制台初始化-tty-init" class="headerlink" title="（4）控制台初始化 tty_init"></a>（4）控制台初始化 tty_init</h3><p>我们通常使用 tty(Teletype) 来简称各种类型的终端设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">	...</span><br><span class="line">	tty_init();</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这个函数执行后，我们会具备键盘输入到显示器输出字符这个最常用的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="rs-init"><a href="#rs-init" class="headerlink" title="rs_init()"></a>rs_init()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    set_intr_gate(<span class="number">0x24</span>,rs1_interrupt);</span><br><span class="line">    set_intr_gate(<span class="number">0x23</span>,rs2_interrupt);</span><br><span class="line">    init(tty_table[<span class="number">1</span>].read_q.data);</span><br><span class="line">    init(tty_table[<span class="number">2</span>].read_q.data);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xE7</span>,<span class="number">0x21</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>开启<strong>串口中断</strong>并设置对应的中断处理程序，串口目前PC机很少使用，不做讲解，知道<code>rs_init</code>干了什么就可以。</p>
<h4 id="con-init"><a href="#con-init" class="headerlink" title="con_init()"></a>con_init()</h4><p>Linux中计算机显示器通常被称为控制台终端或控制台(Console)。</p>
<p>函数大体框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//console.c文件</span></span><br><span class="line"><span class="comment">//根据系统初始化获得的系统信息</span></span><br><span class="line"><span class="comment">//设置有关屏幕的一些基本参数值</span></span><br><span class="line"><span class="comment">//用于con_write()函数的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_VIDEO_MODE ((*(unsigned short *)0x90006) &amp; 0xff) <span class="comment">//显示模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_VIDEO_EGA_BX (*(unsigned short *)0x9000a)<span class="comment">//显示内存大小和色彩模式</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * void con_init(void);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine initalizes console interrupts, and does nothing</span></span><br><span class="line"><span class="comment"> * else. If you want the screen to clear, call tty_write with</span></span><br><span class="line"><span class="comment"> * the appropriate escape-sequece.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Reads the information preserved by setup.s to determine the current display</span></span><br><span class="line"><span class="comment"> * type and sets everything accordingly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">con_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (ORIG_VIDEO_MODE == <span class="number">7</span>) {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="number">0xff</span>) != <span class="number">0x10</span>) {...}</span><br><span class="line">        <span class="keyword">else</span> {...}</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="number">0xff</span>) != <span class="number">0x10</span>) {...}</span><br><span class="line">        <span class="keyword">else</span> {...}</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如此多的<code>if-else</code>是为了应对不同的显示模式，从而分配不同的变量。</p>
<p>👋显示模式</p>
<p>字符如何显示在屏幕上?先看内存给图形的缓冲区。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/picbuf.png" alt></p>
<p>往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;向屏幕输出'hello'</span><br><span class="line"></span><br><span class="line">mov [0xB8000],'h'</span><br><span class="line">mov [0xB8002],'e'</span><br><span class="line">mov [0xB8004],'l'</span><br><span class="line">mov [0xB8006],'l'</span><br><span class="line">mov [0xB8008],'o'</span><br></pre></td></tr></table></figure>
<p>con_init可以简化为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_X          (*(unsigned char *)0x90000) <span class="comment">//光标位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_Y          (*(unsigned char *)0x90001) </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">con_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    <span class="comment">// 第一部分 获取显示模式相关信息</span></span><br><span class="line">    video_num_columns = (((*(<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x90006</span>) &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    video_size_row = video_num_columns * <span class="number">2</span>;</span><br><span class="line">    video_num_lines = <span class="number">25</span>;</span><br><span class="line">    video_page = (*(<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x90004</span>);</span><br><span class="line">    video_erase_char = <span class="number">0x0720</span>;</span><br><span class="line">    <span class="comment">// 第二部分 显存映射的内存区域 ,我们现在假设是文本模式</span></span><br><span class="line">    <span class="comment">//所以内存是从0xB800到0xBA00</span></span><br><span class="line">    video_mem_start = <span class="number">0xb8000</span>;</span><br><span class="line">    video_port_reg  = <span class="number">0x3d4</span>;</span><br><span class="line">    video_port_val  = <span class="number">0x3d5</span>;</span><br><span class="line">    video_mem_end = <span class="number">0xba000</span>;</span><br><span class="line">    <span class="comment">// 第三部分 滚动屏幕操作时的信息</span></span><br><span class="line">    <span class="comment">//设置顶行和底行</span></span><br><span class="line">    origin  = video_mem_start;</span><br><span class="line">    scr_end = video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    bottom  = video_num_lines;</span><br><span class="line">    <span class="comment">// 第四部分 定位光标并开启键盘中断</span></span><br><span class="line">    <span class="comment">//光标位置取内存地址0x90000处的数据</span></span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y); <span class="comment">//x表示列,y表示行</span></span><br><span class="line">    set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);</span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfd</span>,<span class="number">0x21</span>);</span><br><span class="line">    a=inb_p(<span class="number">0x61</span>);</span><br><span class="line">    outb_p(a|<span class="number">0x80</span>,<span class="number">0x61</span>);</span><br><span class="line">    outb(a,<span class="number">0x61</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>现在我们可以通过键盘键入在显示屏显示，下面继续深入看<code>gotoxy</code>函数，定位当前光标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_X          (*(unsigned char *)0x90000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_Y          (*(unsigned char *)0x90001)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">con_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 第四部分 定位光标并开启键盘中断</span></span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">gotoxy</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> new_x,<span class="type">unsigned</span> <span class="type">int</span> new_y)</span> {</span><br><span class="line">   ...</span><br><span class="line">   x = new_x;</span><br><span class="line">   y = new_y;</span><br><span class="line">   pos = origin + y*video_size_row + (x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>pos</code>根据行号和列号算出来内存指针，往<code>pos</code>指向地址处写数据，相当于往控制台的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2284.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1895.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>写入字符，所以按下键盘后，触发键盘中断后的程序调用链是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_keyboard_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    call _do_tty_interrupt</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">do_tty_interrupt</span><span class="params">(<span class="type">int</span> tty)</span> {</span><br><span class="line">   copy_to_cooked(tty_table+tty);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_cooked</span><span class="params">(<span class="keyword">struct</span> tty_struct * tty)</span> {</span><br><span class="line">    ...</span><br><span class="line">    tty-&gt;write(tty);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台时 tty 的 write 为 con_write 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">con_write</span><span class="params">(<span class="keyword">struct</span> tty_struct * tty)</span> {</span><br><span class="line">    ...</span><br><span class="line">    __asm__(<span class="string">"movb _attr,%%ah\n\t"</span></span><br><span class="line">      <span class="string">"movw %%ax,%1\n\t"</span></span><br><span class="line">      ::<span class="string">"a"</span> (c),<span class="string">"m"</span> (*(<span class="type">short</span> *)pos)</span><br><span class="line">      :<span class="string">"ax"</span>);</span><br><span class="line">     pos += <span class="number">2</span>;</span><br><span class="line">     x++;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>我们看最后的<code>con_write</code>函数关键内联汇编代码做的事：</p>
<p>把键盘输入的字符写入pos指针指向的内存，相当于往屏幕输出，<code>pos+=2</code>和<code>x++</code>就是调整光标，所以调整光标的本质就是改变<code>x,y,pos</code>这3个变量。其余的定位光标、滚屏、删除一行等操作在源代码中都有，不难但内容很多，理解基本原理即可。</p>
<p>到此，控制台初始化结束，<code>tty_init()</code>结束。</p>
<p>✍终端与Shell区分</p>
<p>终端：终端是<strong>人与机器交互的接口</strong>，是连接到计算机上的一种带输入输出功能的外设。<strong>在计算机领域，终端是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。</strong>随着个人计算机的普及，控制台 (Console) 与终端 (Terminal) 的概念已经逐渐模糊。在现代，我们的键盘与显示器既可以认为是控制台，也可以认为是普通的终端。当你在管理系统时，它们是控制台；当你在做一般的工作时（浏览网页、编辑文档等），它们就是终端。我们自己既是一般用户，也是系统管理员。因此，<strong>现在 控制台 与 终端 基本被看作是同义词</strong>。</p>
<p>Shell：<strong>提供用户界面的程序</strong>。接受用户输入的命令，然后帮我们与内核沟通，最后让内核完成我们的任务。这个提供用户界面的程序被叫做 <strong>Shell</strong> (壳层)。</p>
<blockquote>
<p>比如说我们想要知道一个文件的内容，我们会在 Shell 中输入命令 <code>cat file.txt</code>，然后 Shell 会帮我们运行 <code>cat</code> 这个程序，<code>cat</code> 再去调用内核提供的 <code>open</code> 等系统调用来获取文件的内容。虽然并不是 Shell 直接去与内核交互，但广义上可以认为是 Shell 提供了与内核交互的用户界面。</p>
</blockquote>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/shell.png" alt></p>
<h3 id="（5）时间初始化-time-init"><a href="#（5）时间初始化-time-init" class="headerlink" title="（5）时间初始化 time_init"></a>（5）时间初始化 time_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_READ(addr) ({ \</span></span><br><span class="line"><span class="meta">    outb_p(0x80|addr,0x70); \</span></span><br><span class="line"><span class="meta">    inb_p(0x71); \</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">time_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        time.tm_sec = CMOS_READ(<span class="number">0</span>);</span><br><span class="line">        time.tm_min = CMOS_READ(<span class="number">2</span>);</span><br><span class="line">        time.tm_hour = CMOS_READ(<span class="number">4</span>);</span><br><span class="line">        time.tm_mday = CMOS_READ(<span class="number">7</span>);</span><br><span class="line">        time.tm_mon = CMOS_READ(<span class="number">8</span>);</span><br><span class="line">        time.tm_year = CMOS_READ(<span class="number">9</span>);</span><br><span class="line">    } <span class="keyword">while</span> (time.tm_sec != CMOS_READ(<span class="number">0</span>));</span><br><span class="line">    BCD_TO_BIN(time.tm_sec);</span><br><span class="line">    BCD_TO_BIN(time.tm_min);</span><br><span class="line">    BCD_TO_BIN(time.tm_hour);</span><br><span class="line">    BCD_TO_BIN(time.tm_mday);</span><br><span class="line">    BCD_TO_BIN(time.tm_mon);</span><br><span class="line">    BCD_TO_BIN(time.tm_year);</span><br><span class="line">    time.tm_mon--;</span><br><span class="line">    startup_time = kernel_mktime(&amp;time);</span><br><span class="line">    <span class="comment">//计算从 1970 年 1 月 1 日 0 时起到开机当时经过的秒数</span></span><br><span class="line">    <span class="comment">//存储在 startup_time变量中</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>获取时间主要是2个函数：</p>
<p><code>CMOS_READ</code>和<code>BCD_TO_BIN</code>，所以我们弄懂这两个函数即可。</p>
<p><strong>CMOS_READ</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_READ(addr) ({ \</span></span><br><span class="line"><span class="meta">    outb_p(0x80|addr,0x70); \</span></span><br><span class="line"><span class="meta">    inb_p(0x71); \</span></span><br><span class="line"><span class="meta">})</span></span><br></pre></td></tr></table></figure>
<p>对一个端口先 <strong>out</strong> 写一下，再 <strong>in</strong> 读一下。</p>
<p>CPU 与外设交互的一个基本玩法：CPU 与外设打交道基本是通过端口，往某些端口<strong>写值</strong>来表示要这个外设干什么，然后从另一些端口读值来<strong>接受外设的反馈</strong>。CPU要打交道的是CMOS外设，它是主板上一个可读写的RAM芯片，代码的操作就是按照CMOS手册要求的读写指定端口，知道是这么回事就行。</p>
<p><strong>BCD_TO_BIN</strong></p>
<p>BCD码值转BIN码值：CMOS上获取的年月日等都是BCD码值，要转换为二进制数值存储。</p>
<p>操作系统很多都是很繁琐地读硬件手册获取信息并使用。</p>
<h3 id="（6）进程调度初始化-sched-init"><a href="#（6）进程调度初始化-sched-init" class="headerlink" title="（6）进程调度初始化 sched_init"></a>（6）进程调度初始化 sched_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    set_tss_desc(gdt+<span class="number">4</span>, &amp;(init_task.task.tss));</span><br><span class="line">    set_ldt_desc(gdt+<span class="number">5</span>, &amp;(init_task.task.ldt));</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>分别对 TSS  和 LDT 初始化。</p>
<p>TSS(<strong>Task State Segment</strong>)：<strong>任务状态段</strong>，占104字节，x86架构中保存任务信息的<strong>数据结构</strong>，用于任务管理 和 存储大部分寄存器的值。CPU中只有任务的概念（任务对应 OS 的线程概念），通过 <code>tr</code> 寄存器（只有1个 tr 寄存器）来确定 TSS 位置。</p>
<p>虽然 Intel 设计的<strong>初衷</strong>是用TSS来做任务切换，然而，在现代操作系统中（无论是 Windows 还是 Linux），都没有使用这种方式来执行任务切换，而是自己实现了线程。主要原因是这种切换速度非常慢，一条指令要消耗200多个时钟周期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span>{</span></span><br><span class="line">    <span class="type">long</span> back_link;</span><br><span class="line">    <span class="type">long</span> esp0;</span><br><span class="line">    <span class="type">long</span> ss0;</span><br><span class="line">    <span class="type">long</span> esp1;</span><br><span class="line">    <span class="type">long</span> ss1;</span><br><span class="line">    <span class="type">long</span> esp2;</span><br><span class="line">    <span class="type">long</span> ss2;</span><br><span class="line">    <span class="type">long</span> cr3;</span><br><span class="line">    <span class="type">long</span> eip;</span><br><span class="line">    <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">long</span> eax, ecx, edx, ebx;</span><br><span class="line">    <span class="type">long</span> esp;</span><br><span class="line">    <span class="type">long</span> ebp;</span><br><span class="line">    <span class="type">long</span> esi;</span><br><span class="line">    <span class="type">long</span> edi;</span><br><span class="line">    <span class="type">long</span> es;</span><br><span class="line">    <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">long</span> ss;</span><br><span class="line">    <span class="type">long</span> ds;</span><br><span class="line">    <span class="type">long</span> fs;</span><br><span class="line">    <span class="type">long</span> gs;</span><br><span class="line">    <span class="type">long</span> ldt;</span><br><span class="line">    <span class="type">long</span> trace_bitmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>LDT(<strong>Local Descriptor Table</strong>)：与GDT对应，CPU厂商为在硬件一级原生支持多任务而创建的表，按照设想，一个任务对应一个LDT。但现代操作系统中<strong>很少使用</strong>LDT。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/tss.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> a,b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[64] =</span> {&amp;(init_task.task), };</span><br><span class="line"><span class="comment">//给一个长度为 64 ，结构为 task_struct 的数组 task 附上初始值</span></span><br><span class="line"><span class="comment">//代表每一个进程的信息 ，管理全部进程的结构。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span></span><br><span class="line">        p = gdt+<span class="number">6</span>;</span><br><span class="line">    <span class="comment">//给 gdt 剩下的位置填充上 0，也就是把剩下留给 TSS 和 LDT 的描述符都先附上空值。</span></span><br><span class="line">    <span class="comment">//以后每创建一个新进程，就会在后面添加一组 TSS 和 LDT 表示这个进程的任务状态段以及局部描述符表信息。</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">64</span>;i++) {</span><br><span class="line">        task[i] = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don't touch */</span></span><br><span class="line">    <span class="type">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    <span class="type">long</span> priority;</span><br><span class="line">    <span class="type">long</span> signal;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span></span><br><span class="line">    <span class="type">long</span> blocked; <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line">  <span class="comment">/* various fields */</span></span><br><span class="line">    <span class="type">int</span> exit_code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code,end_code,end_data,brk,start_stack;</span><br><span class="line">    <span class="type">long</span> pid,father,pgrp,session,leader;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> uid,euid,suid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gid,egid,sgid;</span><br><span class="line">    <span class="type">long</span> alarm;</span><br><span class="line">    <span class="type">long</span> utime,stime,cutime,cstime,start_time;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math;</span><br><span class="line">  <span class="comment">/* file system info */</span></span><br><span class="line">    <span class="type">int</span> tty;  <span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> umask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> close_on_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span></span><br><span class="line">  <span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line">  <span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>初始化一组 TSS 和 LDT ，作为未来进程 0 的 任务状态段 和 局部描述符表 的信息，往下看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ltr(n) __asm__(<span class="string">"ltr %%ax"</span>::<span class="string">"a"</span> (_TSS(n)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lldt(n) __asm__(<span class="string">"lldt %%ax"</span>::<span class="string">"a"</span> (_LDT(n)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    ltr(<span class="number">0</span>);<span class="comment">//给 tr 寄存器赋值，告诉 CPU 任务状态段 TSS 在内存的位置</span></span><br><span class="line">    lldt(<span class="number">0</span>);<span class="comment">//给 ldt 寄存器赋值，告诉 CPU 局部描述符 LDT 在内存的位置</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);      <span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">    outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);    <span class="comment">/* LSB */</span></span><br><span class="line">    outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);    <span class="comment">/* MSB */</span></span><br><span class="line">    set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>四行端口写代码，两行设置中断代码。</p>
<p>这次交互的外设是一个<strong>可编程定时器</strong>的芯片（比如 8253），这四行代码就开启了这个定时器，之后这个定时器变会<strong>持续的、以一定频率的向 CPU 发出中断信号</strong>。</p>
<p>设置两个中断：</p>
<p>第一个就是<strong>时钟中断</strong>，中断处理程序为 <strong>timer_interrupt</strong>，中断号 <strong>0x20</strong>。那么每次定时器向 CPU 发出中断后，便会执行这个函数。</p>
<p>第二个设置的中断叫系统调用 <strong>system_call</strong>，中断号 <strong>0x80</strong>，这个中断又是个非常重要的中断，所有 [用户态程序] 想要调用 [内核] 提供的方法，都需要基于这个系统调用来进行。</p>
<blockquote>
<p>比如 Java 程序员写一个 read，底层会执行汇编指令 <strong>int 0x80</strong>，这就会触发系统调用这个中断，最终调用到 Linux 里的 sys_read 方法。</p>
</blockquote>
<h3 id="（7）缓冲区初始化-buffer-init"><a href="#（7）缓冲区初始化-buffer-init" class="headerlink" title="（7）缓冲区初始化 buffer_init"></a>（7）缓冲区初始化 buffer_init</h3><p>👋本部分涉及到大量<strong>链表</strong>和<strong>哈希表</strong>的知识，建议好好学习数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer_init(buffer_memory_end);</span><br></pre></td></tr></table></figure>
<p>这个 <code>buffer_memory_end</code> 是很早之前就设置好的，是指定的缓冲区内存末端，对于 8MB 内存系统，缓冲区末端设置 2MB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> {</span></span><br><span class="line">    <span class="type">char</span> *b_data;               <span class="comment">// 指向缓存的数据块的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> b_blocknr;    <span class="comment">// 逻辑块号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b_dev;       <span class="comment">// 设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b_uptodate;   <span class="comment">// 缓存中的数据是否是最新的</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b_dirt;       <span class="comment">// 缓存中数据是否为脏数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b_count;      <span class="comment">// 这个缓存块被引用的次数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b_lock;       <span class="comment">// b_lock表示这个缓存块是否被加锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">b_wait</span>;</span> <span class="comment">// 等待在这个缓存块上的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_prev</span>;</span> <span class="comment">// 指向缓存中相同hash值的下一个缓存块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next</span>;</span> <span class="comment">// 指向缓存中相同hash值的上一个缓存块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_prev_free</span>;</span> <span class="comment">// 缓存块空闲链表中指向下一个缓存块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_next_free</span>;</span> <span class="comment">// 缓存块空闲链表中指向上一个缓存块</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> end;</span><br><span class="line"><span class="comment">//end不是OS写的，而是由链接器链接整个程序时的一个外部变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">start_buffer</span> =</span> (<span class="keyword">struct</span> buffer_head *) &amp;end; <span class="comment">//缓冲区开始位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buffer_init</span><span class="params">(<span class="type">long</span> buffer_end)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> =</span> start_buffer;</span><br><span class="line">    <span class="type">void</span> * b = (<span class="type">void</span> *) buffer_end;</span><br><span class="line">    <span class="keyword">while</span> ( (b -= <span class="number">1024</span>) &gt;= ((<span class="type">void</span> *) (h+<span class="number">1</span>)) ) {</span><br><span class="line">        h-&gt;b_dev = <span class="number">0</span>;			<span class="comment">// 使用该缓冲区的设备号</span></span><br><span class="line">        h-&gt;b_dirt = <span class="number">0</span>;			<span class="comment">// 缓冲区修改标志</span></span><br><span class="line">        h-&gt;b_count = <span class="number">0</span>;			<span class="comment">// 该缓冲区引用计数</span></span><br><span class="line">        h-&gt;b_lock = <span class="number">0</span>;			<span class="comment">// 缓冲区锁定标志</span></span><br><span class="line">        h-&gt;b_uptodate = <span class="number">0</span>;		<span class="comment">// 缓冲区更新标志（数据有效标志）</span></span><br><span class="line">        h-&gt;b_wait = <span class="literal">NULL</span>;		<span class="comment">// 指向等待该缓冲区解锁的进程</span></span><br><span class="line">        h-&gt;b_next = <span class="literal">NULL</span>;		<span class="comment">// 指向具有相同hash值的下一个缓冲头</span></span><br><span class="line">        h-&gt;b_prev = <span class="literal">NULL</span>;		<span class="comment">// 指向具有相同hash值的前一个缓冲头</span></span><br><span class="line">        h-&gt;b_data = (<span class="type">char</span> *) b;</span><br><span class="line">        h-&gt;b_prev_free = h<span class="number">-1</span>;</span><br><span class="line">        h-&gt;b_next_free = h+<span class="number">1</span>;</span><br><span class="line">        h++;</span><br><span class="line">    }</span><br><span class="line">    h--; <span class="comment">// 让 h 指向最后一个有效缓冲头</span></span><br><span class="line">    free_list = start_buffer; <span class="comment">// 让空闲链表头指向头一个缓冲区头</span></span><br><span class="line">    free_list-&gt;b_prev_free = h;</span><br><span class="line">    h-&gt;b_next_free = free_list;<span class="comment">//h的下一项指针指向第一项，从而形成一个环链</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">307</span>;i++)</span><br><span class="line">        hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/bu.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buffer_init</span><span class="params">(<span class="type">long</span> buffer_end)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> =</span> start_buffer;</span><br><span class="line">    <span class="type">void</span> * b = (<span class="type">void</span> *) buffer_end;</span><br><span class="line">    <span class="comment">// b 表示缓冲块 ，h 表示缓冲头 , h+1 表示缓冲头末端</span></span><br><span class="line">    <span class="comment">//为了保证有足够长度的内存来存储一个缓冲头结构，需要 b 所指向的内存块 </span></span><br><span class="line">    <span class="comment">//地址 &gt;= h 缓冲头的末端，也即要&gt;=h+1。</span></span><br><span class="line">    <span class="keyword">while</span> ( (b -= <span class="number">1024</span>) &gt;= ((<span class="type">void</span> *) (h+<span class="number">1</span>)) ) {</span><br><span class="line">        <span class="comment">// 1024 是每页的值</span></span><br><span class="line">        ...</span><br><span class="line">        h-&gt;b_data = (<span class="type">char</span> *) b;<span class="comment">// 指向对应缓冲区数据块（1024 字节）</span></span><br><span class="line">        h-&gt;b_prev_free = h<span class="number">-1</span>;  <span class="comment">// 指向链表中前一项</span></span><br><span class="line">        h-&gt;b_next_free = h+<span class="number">1</span>;  <span class="comment">// 指向链表中下一项</span></span><br><span class="line">        h++;				   <span class="comment">// h 指向下一新缓冲头位置</span></span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>对于数据结构 : 缓冲头 h 的所有 next 和 prev 指针都指向彼此时，就构成了一个双向链表。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/bh.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buffer_init</span><span class="params">(<span class="type">long</span> buffer_end)</span> {</span><br><span class="line">    ...</span><br><span class="line">    free_list = start_buffer;</span><br><span class="line">    free_list-&gt;b_prev_free = h;</span><br><span class="line">    h-&gt;b_next_free = free_list;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>free_list</code> 指向了缓冲头双向链表的第一个结构，然后就可以顺着这个结构，从双向链表中遍历到任何一个<strong>缓冲头</strong>结构了，而通过缓冲头又可以找到这个缓冲头对应的<strong>缓冲块</strong>。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/freelist.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">buffer_init</span><span class="params">(<span class="type">long</span> buffer_end)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">307</span>;i++)</span><br><span class="line">        hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 初始化 hash 表（哈希表、散列表），置表中所有的指针为 NULL</span></span><br><span class="line"><span class="comment">// 此段代码可以更有助于 管理 和 查找</span></span><br></pre></td></tr></table></figure>
<p><code>buffer_init</code>在<code>buffer.c</code>文件中，这个c文件属于<code>fs</code>即<strong>文件系统</strong>，是为后面的文件系统服务的，具体来讲：内核程序如果访问块设备中的数据，就要经过缓冲区来间接操作。</p>
<p>那么，怎么知道缓冲区已经有了要读取的块设备中的数据？</p>
<p>一种思路：遍历上面那个双向链表，但是效率太低</p>
<p>所以，创建了<code>hash_table</code>的结构来方便快速查找，后面想读取某个块设备上的数据时，首先要搜索相应的缓冲块，<code>getblk</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _hashfn(dev,block) (((unsigned)(dev^block))%307)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索合适的缓冲块 </span></span><br><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">getblk</span><span class="params">(<span class="type">int</span> dev,<span class="type">int</span> block)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> <span class="title">bh</span> =</span> get_hash_table(dev,block)；</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> buffer_head * <span class="title function_">get_hash_table</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> block)</span> {</span><br><span class="line">    ...    </span><br><span class="line">    find_buffer(dev,block);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buffer_head * <span class="title function_">find_buffer</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> block)</span> { </span><br><span class="line">    ...     </span><br><span class="line">    hash(dev,block);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>计算hash值的散列函数表达式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(b_dev ^ b_blocknr) % NR_HASH</span><br><span class="line"><span class="comment">// 其中NR_HASH是散列表的条目总数</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/hstb.png" alt></p>
<h3 id="（8）硬盘初始化-hd-init"><a href="#（8）硬盘初始化-hd-init" class="headerlink" title="（8）硬盘初始化 hd_init"></a>（8）硬盘初始化 hd_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    hd_init(); </span><br><span class="line">    floppy_init(); <span class="comment">// 软盘初始化，但是2011年软盘就被淘汰了，没必要学</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>hd_init()</code>在<code>hd.c</code>文件中，属于<strong>块设备驱动程序</strong>(block driver)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">{ </span><br><span class="line">	blk_dev[<span class="number">3</span>].request_fn = DEVICE_REQUEST;</span><br><span class="line">   <span class="comment">// do_hd_request()。 </span></span><br><span class="line">set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt); </span><br><span class="line">   <span class="comment">//设置硬盘中断向量 int 0x2E(46)。 </span></span><br><span class="line">   <span class="comment">// hd_interrupt 在(kernel/system_call.s,221)。 </span></span><br><span class="line">	outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>); </span><br><span class="line">   <span class="comment">//复位接联的主 8259A int2 的屏蔽位，允许从片发出中断请求信号。 </span></span><br><span class="line">	outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xbf</span>,<span class="number">0xA1</span>); </span><br><span class="line">   <span class="comment">//复位硬盘的中断请求屏蔽位（在从片上），允许硬盘控制器发送中断请求信号。 </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>对于硬件的初始化都是一个套路：</p>
<p>①往某些 IO 端口上读写一些数据，表示开启它</p>
<p>②再向中断向量表中添加一个中断，使得 CPU 能够响应这个硬件设备的动作</p>
<p>③最后初始化一些数据结构来<strong>管理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    blk_dev[<span class="number">3</span>].request_fn = do_hd_request;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>内核使用<code>blk_dev[]</code>来管理块设备，每一个索引表示一个块设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> {</span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> },     <span class="comment">/* no_dev */</span></span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> },     <span class="comment">/* dev mem */</span></span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> },     <span class="comment">/* dev fd */</span> <span class="comment">//&lt;==3号索引</span></span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> },     <span class="comment">/* dev hd */</span></span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> },     <span class="comment">/* dev ttyx */</span></span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> },     <span class="comment">/* dev tty */</span></span><br><span class="line">    { <span class="literal">NULL</span>, <span class="literal">NULL</span> }      <span class="comment">/* dev lp */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>每个块设备执行读写请求都有自己的函数实现，在上层看来都是一个统一函数 <code>request_fn</code> 即可，具体实现各有不同，对于硬盘来说，这个实现就是 <code>do_hd_request</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>设置一个中断，中断号是 <strong>0x2E</strong>，中断处理函数是 <strong>hd_interrupt</strong>，也就是说硬盘发生读写时，硬盘会发出中断信号给 CPU，之后 CPU 进入中断处理程序，即：执行 <code>hd_interrupt</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_hd_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    xchgl _do_hd,%edx</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果是读盘操作，这个 do_hd 是 read_intr</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_intr</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    do_hd_request();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>操作系统就是一个靠中断驱动的死循环而已</strong>，如果不发生任何中断，操作系统会一直在一个死循环里等待。换句话说，让操作系统工作的唯一方式，就是触发中断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hd_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);</span><br><span class="line">    outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xbf</span>,<span class="number">0xA1</span>); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>往对应的 I/O端口写数据，作用是<strong>允许硬盘控制器发送中断请求信号</strong>，导致硬盘开启中断。</p>
<h3 id="（9）打开中断-sti"><a href="#（9）打开中断-sti" class="headerlink" title="（9）打开中断 sti"></a>（9）打开中断 sti</h3><p>本质上是将 eflags 寄存器里的中断允许标志位 IF 位 <strong>置 1</strong>。</p>
<p>直到此时，CPU才可以接收并处理中断信号，我们可以按键盘，硬盘可以读写，时钟开始计时，系统调用也开始生效，OS具备控制台交互、硬盘读写、进程调度、响应用户进程等能力。</p>
<h2 id="0x05-进程0"><a href="#0x05-进程0" class="headerlink" title="0x05 进程0"></a>0x05 进程0</h2><h3 id="（1）切换用户态"><a href="#（1）切换用户态" class="headerlink" title="（1）切换用户态"></a>（1）切换用户态</h3><p>Linux 将操作系统特权级分为用户态与内核态两种，之前都处于内核态，现在要先转变为用户态，一旦转变为了用户态，那么之后的代码将一直处于用户态的模式，除非发生了中断，比如用户发出了系统调用的中断指令，那么此时将会从用户态陷入内核态，不过当中断处理程序执行完之后，又会通过中断返回指令从内核态回到用户态。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/yht.png" alt></p>
<p>内核态切换为用户态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_to_user_mode;</span><br></pre></td></tr></table></figure>
<p>内核态与用户态的本质-特权级</p>
<p><strong>处于内核态的代码可以访问任何特权级的数据段，处于用户态的代码则只可以访问用户态的数据段；代码跳转只能同特权级，数据访问只能高特权级访问低特权级。</strong></p>
<p>所以用户态和内核态之间的转换本质上就是特权级的转换，下面阐述特权级转换的方式：中断 和 中断返回</p>
<p>系统调用就是通过中断实现的，比如用户通过<code>int 0x80</code>中断指令触发中断，CPU切换至内核态，执行中断处理程序，然后中断返回切换回用户态。实际上，没有中断也可以中断返回，很奇怪是不是？但Intel的CPU就是这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define move_to_user_mode() \</span><br><span class="line">_asm { \</span><br><span class="line">    _asm mov eax,esp \</span><br><span class="line">    _asm push 00000017h \ ;给 ss 赋值</span><br><span class="line">    _asm push eax \</span><br><span class="line">    _asm pushfd \</span><br><span class="line">    _asm push 0000000fh \ ;给 cs 赋值</span><br><span class="line">    _asm push offset l1 \ ;设置标号为 l1 的位置</span><br><span class="line">    _asm iretd /* 执行中断返回指令*/ \</span><br><span class="line">_asm l1: mov eax,17h \</span><br><span class="line">    _asm mov ds,ax \</span><br><span class="line">    _asm mov es,ax \</span><br><span class="line">    _asm mov fs,ax \</span><br><span class="line">    _asm mov gs,ax \</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>为什么之前进行了一共<strong>五次的压栈操作呢</strong>？因为中断返回理论上就是应该和中断配合使用的，而此时并不是真的发生了中断到这里，所以我们得<strong>假装发生了中断</strong>才行。其实就把栈做做工作就好了，中断发生时，CPU 会自动帮我们做如下的压栈操作。而中断返回时，CPU 又会帮我们把压栈的这些值返序赋值给响应的寄存器。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/stack.png" alt></p>
<p>此时内核态变为了用户态，顺便设置了栈段、代码段和数据段的基地址。</p>
<h3 id="（2）fork创建进程"><a href="#（2）fork创建进程" class="headerlink" title="（2）fork创建进程"></a>（2）fork创建进程</h3><blockquote>
<p>fork()系统调用用于创建子进程。Linux 中所有进程都是进程 0（任务 0）的子进程。</p>
</blockquote>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/fo.png" alt></p>
<p>操作系统只有一个执行流，就是我们一直看过来的所有代码，就是进程 0，只不过我们并没有意识到它也是一个进程。调用完 fork 之后，现在又多了一个进程，叫做进程 1。</p>
<p>进程调度的本质，就是一会执行这个，再一会执行那个，如果依靠程序自己来进行中断不靠谱，所以要设计一个<strong>不受任何程序控制的，第三方的不可抗力</strong>，每隔一段时间就中断一下 CPU 的运行，然后跳转到一个<strong>特殊的程序</strong>那里，这个程序通过某种方式获取到 CPU 下一个要运行的程序的地址，然后跳转过去。</p>
<p>每隔一段时间就中断 CPU 的不可抗力，就是由定时器触发的<strong>时钟中断</strong>。</p>
<p>这个<strong>特殊的程序</strong>，就是具体的<strong>进程调度函数</strong>。</p>
<p>首先，我们需要一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    ?</span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<p>这个结构要记录各个进程信息，比如：上次执行到哪里，下次要到哪一行运行等等。</p>
<h4 id="上下文环境-tss"><a href="#上下文环境-tss" class="headerlink" title="上下文环境 tss"></a>上下文环境 tss</h4><p>每个程序最终的本质就是执行指令。这个过程会涉及<strong>寄存器</strong>，<strong>内存</strong>和<strong>外设端口</strong>。不过寄存器一共就那么点，肯定做不到互不干扰，可能一个进程就把寄存器全用上了，那其他进程怎么办？</p>
<p>最稳妥的做法就是，每次切换进程时，都把当前这些寄存器的值存到一个地方，以便之后切换回来的时候恢复。linux0.11中，每个进程的结构 task_struct 里面，有一个叫 <strong>tss</strong> 的结构，存储的就是 CPU 这些<strong>寄存器</strong>的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> {</span></span><br><span class="line">    <span class="type">long</span>    back_link;  <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    esp0;</span><br><span class="line">    <span class="type">long</span>    ss0;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    esp1;</span><br><span class="line">    <span class="type">long</span>    ss1;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    esp2;</span><br><span class="line">    <span class="type">long</span>    ss2;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    cr3;</span><br><span class="line">    <span class="type">long</span>    eip;</span><br><span class="line">    <span class="type">long</span>    eflags;</span><br><span class="line">    <span class="type">long</span>    eax,ecx,edx,ebx;</span><br><span class="line">    <span class="type">long</span>    esp;</span><br><span class="line">    <span class="type">long</span>    ebp;</span><br><span class="line">    <span class="type">long</span>    esi;</span><br><span class="line">    <span class="type">long</span>    edi;</span><br><span class="line">    <span class="type">long</span>    es;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    cs;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    ss;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    ds;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    fs;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    gs;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    ldt;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="type">long</span>    trace_bitmap;   <span class="comment">/* bits: trace 0, bitmap 16-31 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p><strong>cr3</strong>是指向页目录表首地址的寄存器。指向不同的页目录表，整个页表结构就是完全不同的一套，那么线性地址到物理地址的映射关系就有能力做到不同。</p>
<h4 id="运行时间信息-counter"><a href="#运行时间信息-counter" class="headerlink" title="运行时间信息 counter"></a>运行时间信息 counter</h4><p>剩余时间片：每次时钟中断来了之后都 <strong>-1</strong>，如果减到 0 了，就触发切换进程的操作。linux0.11中，这个属性是 <code>counter</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>用法也非常简单，就是每次中断都判断一下<code>counter</code>是否到 0，如果到0就开始进程的调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">long</span> cpl)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 当前线程还有剩余时间片，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 若没有剩余时间片，调度</span></span><br><span class="line">    schedule();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="优先级-priority"><a href="#优先级-priority" class="headerlink" title="优先级 priority"></a>优先级 priority</h4><p>上面有counter，但是counter初始化怎么办？这就是涉及到优先级的问题，也要有一个属性来记录这个值。counter值越大，每次轮到这个进程时，它在 CPU 中运行的时间就越长，也就是这个进程比其他进程得到了更多 CPU 运行的时间。</p>
<p>我们把这个具体的数值叫做<strong>优先级</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    <span class="type">long</span> priority;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="进程状态-state"><a href="#进程状态-state" class="headerlink" title="进程状态 state"></a>进程状态 state</h4><p>我们知道进程是代码运行的实体，而进程有可能是正在运行的，也可能是已经停止的，这就是进程的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span></span><br><span class="line">    <span class="type">long</span> state;</span><br><span class="line">    <span class="type">long</span> counter;</span><br><span class="line">    <span class="type">long</span> priority;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING          0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_ZOMBIE           3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED          4</span></span><br></pre></td></tr></table></figure>
<p>现在我们有了 上下文环境、时间片、优先级、进程状态这些基础，我们可以进行进程调度，下面讲一下进程调度全过程。</p>
<h4 id="定时器与进程调度"><a href="#定时器与进程调度" class="headerlink" title="定时器与进程调度"></a>定时器与进程调度</h4><p>定时器每间隔 10 ms向CPU发起中断信号，即 100 Hz。发起的中断叫<strong>时钟中断</strong>，其中断向量号被设置为了 <strong>0x20</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HZ 100</span></span><br></pre></td></tr></table></figure>
<p>当时钟中断也就是 <strong>0x20</strong>中断来时候，CPU查找中断向量表中 0x20 处的函数地址，即中断处理函数，并跳过去执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">system_call.s</span><br><span class="line"></span><br><span class="line">_timer_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    // 增加系统滴答数</span><br><span class="line">    incl _jiffies</span><br><span class="line">    ...</span><br><span class="line">    // 调用函数 do_timer</span><br><span class="line">    call _do_timer</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> i, next, c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        <span class="keyword">while</span> (--i) {</span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                        (*p)-&gt;priority;</span><br><span class="line">    }</span><br><span class="line">    switch_to(next);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>对<code>schedule</code>进行简化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> next = get_max_counter_and_runnable_thread();</span><br><span class="line">    refresh_all_thread_counter();</span><br><span class="line">    switch_to(next);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这个函数就做了三件事：</p>
<p>1.拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。</p>
<p>2.如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 <code>runnable</code> 的进程）的 counter 重新赋值（<code>counter = counter/2 + priority</code>），然后再次执行步骤 1。</p>
<p>3.最后拿到了一个进程号 next，调用了 <code>switch_to(next)</code> 这个方法，就切换到了这个进程去执行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sched.h</span><br><span class="line"></span><br><span class="line">#define switch_to(n) {\</span><br><span class="line">struct {long a,b;} __tmp; \</span><br><span class="line">__asm__("cmpl %%ecx,_current\n\t" \</span><br><span class="line">    "je 1f\n\t" \</span><br><span class="line">    "movw %%dx,%1\n\t" \</span><br><span class="line">    "xchgl %%ecx,_current\n\t" \</span><br><span class="line">    "ljmp %0\n\t" \</span><br><span class="line">    "cmpl %%ecx,_last_task_used_math\n\t" \</span><br><span class="line">    "jne 1f\n\t" \</span><br><span class="line">    "clts\n" \</span><br><span class="line">    "1:" \</span><br><span class="line">    ::"m" (*&amp;__tmp.a),"m" (*&amp;__tmp.b), \</span><br><span class="line">    "d" (_TSS(n)),"c" ((long) task[n])); \</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>主要就干了一件事，就是 ljmp 到新进程的 tss 段处。CPU 规定，如果 ljmp 指令后面跟的是一个 tss 段，那么，会由硬件将当前各个寄存器的值保存在当前进程的 tss 中，并将新进程的 tss 信息加载到各个寄存器。即：<strong>保存当前进程上下文，恢复下一个进程的上下文，跳过去</strong>。</p>
<p>进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 <code>switch_to</code> 函数的入参里。<code>switch_to</code> 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</p>
<p>前面讲的进程调度相关数据结构和函数，都是为了下面讲解<code>fork()</code>做铺垫。</p>
<h4 id="正式进入-fork"><a href="#正式进入-fork" class="headerlink" title="正式进入 fork()"></a>正式进入 fork()</h4><blockquote>
<p>fork()系统调用用于创建子进程。Linux 中所有进程都是进程 0（任务 0）的子进程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static _inline _syscall0(int,fork)</span><br><span class="line"></span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">{ \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile ("int $0x80" \</span><br><span class="line">    : "=a" (__res) \</span><br><span class="line">    : "0" (__NR_##name)); \</span><br><span class="line">if (__res &gt;= 0) \</span><br><span class="line">    return (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>我们把宏定义展开，就相当于定义了一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int fork(void) {</span><br><span class="line">     volatile long __res;</span><br><span class="line">    _asm {</span><br><span class="line">        _asm mov eax,__NR_fork ;__NR_fork的值是2</span><br><span class="line">        _asm int 80h</span><br><span class="line">        _asm mov __res,eax</span><br><span class="line">    }</span><br><span class="line">    if (__res &gt;= 0)</span><br><span class="line">        return (void) __res;</span><br><span class="line">    errno = -__res;</span><br><span class="line">    return -1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中 0x80 号软中断是在 <strong>sched_init</strong> 中设置的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(<span class="number">0x80</span>, &amp;system_call);</span><br></pre></td></tr></table></figure>
<p>👋软中断：执行<strong>中断指令</strong>产生</p>
<p>👋硬中断：由<strong>外设</strong>引发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">    ...</span><br><span class="line">    call [_sys_call_table + eax*4]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>eax 寄存器里的值是 2，所以这个就是在这个 <strong>sys_call_table</strong> 表里找下标 2 位置处的函数，然后跳转过去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">  sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,</span><br><span class="line">  sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,</span><br><span class="line">  sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,</span><br><span class="line">  sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,</span><br><span class="line">  sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,</span><br><span class="line">  sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,</span><br><span class="line">  sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,</span><br><span class="line">  sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,</span><br><span class="line">  sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,</span><br><span class="line">  sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,</span><br><span class="line">  sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,</span><br><span class="line">  sys_setreuid, sys_setregid</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>各种函数指针组成的一个数组，说白了就是个系统调用函数表，标号2处正好是<code>sys_fork()</code>函数。</p>
<p>所以<code>fork()</code>的流程就是：OS通过中断<code>int 0x80</code>使用系统调用<code>_system_call</code>，根据<code>eax</code>和<code>_sys_call_table</code>的值找系统调用函数表和对应位置的功能函数<code>sys_fork()</code>。<code>fork()</code>的本质就是：一个包装好的方法，通过<code>int 0x80</code>， 赋值给 <code>eax</code> ，使用系统调用。</p>
<p>系统调用就这么个流程，后面很多函数都是这个流程。</p>
<p>那么，<code>sys_fork()</code>函数都做了什么？</p>
<p>1.找到空闲的进程位置</p>
<p>2.复制进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">    call _find_empty_process</span><br><span class="line">    testl %eax,%eax</span><br><span class="line">    js 1f</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %esi</span><br><span class="line">    pushl %edi</span><br><span class="line">    pushl %ebp</span><br><span class="line">    pushl %eax</span><br><span class="line">    call _copy_process</span><br><span class="line">    addl $20,%esp</span><br><span class="line">1:  ret</span><br></pre></td></tr></table></figure>
<p>我们前面学过，存储进程的数据结构是一个 task[64] 数组，我们要先在这个数组中找一个空闲的位置，准备存一个新的进程的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>{</span></span><br><span class="line">	<span class="type">long</span> state;</span><br><span class="line">	<span class="type">long</span> counter;</span><br><span class="line">	<span class="type">long</span> priority;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// long: 8Byte x 8Bit = 64Bit</span></span><br></pre></td></tr></table></figure>
<p>1.先来找空闲位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> last_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_empty_process</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    repeat:</span><br><span class="line">        <span class="keyword">if</span> ((++last_pid)&lt;<span class="number">0</span>) last_pid=<span class="number">1</span>; <span class="comment">//保护作用</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;<span class="number">64</span> ; i++) <span class="comment">//如果task[i]被进程占用，则继续寻找，直到找到一个pid号没有被任何进程使用为止。</span></span><br><span class="line">            <span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) <span class="keyword">goto</span> repeat; <span class="comment">// :)?Linus用的是goto语句</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span> ; i&lt;<span class="number">64</span>; i++) <span class="comment">//找到了空闲项</span></span><br><span class="line">        <span class="keyword">if</span> (!task[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 最后返回数组索引，表示找到了空闲项，在对应位置塞一个进程</span></span><br></pre></td></tr></table></figure>
<p>2.找到空闲位置后，我们要<strong>复制进程</strong>，但是现在只有一个进程，就是数组中位置 0 处的 <strong>init_task.init</strong>，也就是零号进程。上面的方法运行后，last_pid是1，即：新进程被分配的pid就是1，加入到task[]数组索引位置就是1。</p>
<p>下面看一下如何把进程结构塞到 1 这个索引位置的task[]中。</p>
<p>函数去掉tss结构的复制和一些无关紧要的分支后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个是主要的fork子程序，复制系统进程信息并设置必要的寄存器*/</span></span><br><span class="line"><span class="comment">/*还整个复制数据段*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr, ...)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">p</span> =</span> (<span class="keyword">struct</span> task_struct *) get_free_page(); <span class="comment">// 为新任务数据结构分配内存</span></span><br><span class="line">    task[nr] = p;<span class="comment">// nr为任务号，由上面的find_empty_process返回</span></span><br><span class="line">    *p = *current;<span class="comment">/* 注意！这样做不会复制超级用户的堆栈 */</span></span><br><span class="line"></span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE; <span class="comment">// 将新进程的状态先置为不可中断等待状态</span></span><br><span class="line">    p-&gt;pid = last_pid; <span class="comment">// 新进程号。由前面调用 find_empty_process()得到</span></span><br><span class="line">    p-&gt;counter = p-&gt;priority;</span><br><span class="line">    ..</span><br><span class="line">    p-&gt;tss.edx = edx;</span><br><span class="line">    p-&gt;tss.ebx = ebx;</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    ...</span><br><span class="line">    copy_mem(nr,p);</span><br><span class="line">    ...</span><br><span class="line">    set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">    set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>👋👋这段函数是fork()的重难点👋👋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">p</span> =</span> (<span class="keyword">struct</span> task_struct *) get_free_page();</span><br></pre></td></tr></table></figure>
<p>遍历 mem_map[] 数组，找出值为 0 的项，就找到了空闲的一页内存，再把对应值设置为 1 ，表示这一页已经被使用，最后算出这个页的起始内存地址，返回，赋值给 p。</p>
<p>这时，一个进程的结构<code>task_struct</code>就在内存中有了一块空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task[nr] = p;</span><br><span class="line">*p = *current;</span><br><span class="line"><span class="comment">/*把当前进程，即0号进程的 task_struct 全部值赋值给进程p*/</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cu.png" alt></p>
<p>进程 1 和进程 0 目前是完全复制的关系，但有一些值是需要个性化处理的，下面的代码就是把这些不一样的值覆盖掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr, ...)</span> {</span><br><span class="line">    ...</span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    p-&gt;pid = last_pid;</span><br><span class="line">    p-&gt;counter = p-&gt;priority;</span><br><span class="line">    ..</span><br><span class="line">    p-&gt;tss.edx = edx;</span><br><span class="line">    p-&gt;tss.ebx = ebx;</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    ...</span><br><span class="line">    p-&gt;tss.esp0 = PAGE_SIZE + (<span class="type">long</span>) p;</span><br><span class="line">    p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>现在进程1在内存中已经占上一个坑了，下面要规划这个进程的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr, ...)</span> {</span><br><span class="line">    ...</span><br><span class="line">    copy_mem(nr,p);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span> {</span><br><span class="line">    <span class="comment">// 局部描述符表 LDT 赋值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> old_data_base,new_data_base,data_limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> old_code_base,new_code_base,code_limit;</span><br><span class="line">    code_limit = get_limit(<span class="number">0x0f</span>);</span><br><span class="line">    data_limit = get_limit(<span class="number">0x17</span>);</span><br><span class="line">    new_code_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">    new_data_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">    set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);</span><br><span class="line">    set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);</span><br><span class="line">    <span class="comment">// 拷贝页表</span></span><br><span class="line">    old_code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line">    old_data_base = get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">    copy_page_tables(old_data_base,new_data_base,data_limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="LDT赋值"><a href="#LDT赋值" class="headerlink" title="LDT赋值"></a>LDT赋值</h5><p>32 位的 CPU 线性地址空间应为 4G，前 16M 内存线性地址空间已经与 16M 物理地址空间对应起来了。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/fz.png" alt></p>
<p>我们目前已知的：进程0准备好了LDT的代码段和数据段，段基址都为0，段限长为640K。我们现在要做的：给进程1的代码段和数据段赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span> {</span><br><span class="line">    ...</span><br><span class="line">    code_limit = get_limit(<span class="number">0x0f</span>);</span><br><span class="line">    data_limit = get_limit(<span class="number">0x17</span>);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>段基址是取决于当前是几号进程，也就是 nr 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span> {</span><br><span class="line">    ...</span><br><span class="line">    new_code_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">    new_data_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 0x4000000就是 64M</span></span><br></pre></td></tr></table></figure>
<p>也就是说，今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间，并且紧挨着。</p>
<p>然后<strong>把 LDT 设置进入 LDT 表</strong>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span> {</span><br><span class="line">    ...</span><br><span class="line">    set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);<span class="comment">// 设置代码段描述符中基址域</span></span><br><span class="line">    set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);<span class="comment">// 设置数据段描述符中基址域</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/sz.png" alt></p>
<p>经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是<strong>段式</strong>管理。</p>
<h5 id="页表拷贝"><a href="#页表拷贝" class="headerlink" title="页表拷贝"></a>页表拷贝</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_mem</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// old=0, new=64M, limit=640K</span></span><br><span class="line">    copy_page_tables(old_data_base,new_data_base,data_limit)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>进程 0 有<strong>一个页目录表</strong>和<strong>四个页表</strong>，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。</p>
<p>现在进程 0 的线性地址空间是 0 - 64M，进程 1 的线性地址空间是 64M - 128M。<strong>我们现在要造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间<u>都是</u> 0 - 64M</strong>，这样进程 1 才能顺利运行起来，不然就乱套了。<strong>最后，将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备。</strong></p>
<p>我们知道最后这段代码实现了上面的功能即可，代码中的计算非常绕。</p>
<p>把进程的基本信息、内存规划都完成后，设置状态为<code>TASK_RUNNING</code>，表明该进程允许被调度。</p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/fork-system-call/">拓展：fork()编程相关拓展1</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jason314/article/details/5640969">拓展：fork()编程相关拓展2</a></p>
<h3 id="（3）pause-死循环"><a href="#（3）pause-死循环" class="headerlink" title="（3）pause 死循环"></a>（3）pause 死循环</h3><p>当没有任何可运行的进程时，操作系统会悬停在这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) pause();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于任何其它的任务， pause() 将意味着我们必须等待收到一个信号才会返回就绪运行态，但任务 0（task0）是唯一的意外情况，因为任务 0 在任何空闲时间里都会被激活（当没有其它任务在运行时），因此对于任务 0 ，pause() 仅意味着我们返回来查看是否有其它任务可以运行，如果没有的话我们就回到这里，一直循环执行 pause() 。</p>
</blockquote>
<h2 id="0x06-Shell-登场-init"><a href="#0x06-Shell-登场-init" class="headerlink" title="0x06 Shell 登场 - init"></a>0x06 Shell 登场 - init</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> pid,i;</span><br><span class="line">    setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">    (<span class="type">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">    (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">    (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pid=fork())) {</span><br><span class="line">        open(<span class="string">"/etc/rc"</span>,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">        execve(<span class="string">"/bin/sh"</span>,argv_rc,envp_rc);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line">            <span class="comment">/* nothing */</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!pid=fork()) {</span><br><span class="line">            close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">            setsid();</span><br><span class="line">            (<span class="type">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">            (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">            (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">            _exit(execve(<span class="string">"/bin/sh"</span>,argv,envp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        sync();</span><br><span class="line">    }</span><br><span class="line">    _exit(<span class="number">0</span>);   <span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="1-硬盘信息获取"><a href="#1-硬盘信息获取" class="headerlink" title="1.硬盘信息获取"></a>1.硬盘信息获取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drive_info</span> {</span> <span class="type">char</span> dummy[<span class="number">32</span>]; } drive_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drive_info = (*(struct drive_info *)0x90080);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>0x90080</code>是<code>setup.s</code>程序将硬盘 1 的参数信息放在了这里，包括：</p>
<p>·柱面数 <strong>C</strong>ylinders</p>
<p>·磁头数 <strong>H</strong>eaders</p>
<p>·扇区数 <strong>S</strong>ectors</p>
<h4 id="sys-setup"><a href="#sys-setup" class="headerlink" title="sys_setup"></a>sys_setup</h4><p>setup 是系统调用，通过中断最终调用 sys_setup 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> {</span><br><span class="line"></span><br><span class="line">    hd_info[<span class="number">0</span>].cyl = *(<span class="type">unsigned</span> <span class="type">short</span> *) BIOS;</span><br><span class="line">    hd_info[<span class="number">0</span>].head = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">2</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].wpcom = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">5</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].ctl = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">8</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].lzone = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">12</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].sect = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">14</span>+BIOS);</span><br><span class="line">    BIOS += <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    hd[<span class="number">0</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">    hd[<span class="number">0</span>].nr_sects = </span><br><span class="line">        hd_info[<span class="number">0</span>].head * hd_info[<span class="number">0</span>].sect * hd_info[<span class="number">0</span>].cyl;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> bread(<span class="number">0x300</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span> =</span> <span class="number">0x1BE</span> + (<span class="type">void</span> *)bh-&gt;b_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) {</span><br><span class="line">        hd[i].start_sect = p-&gt;start_sect;</span><br><span class="line">        hd[i].nr_sects = p-&gt;nr_sects;</span><br><span class="line">    }</span><br><span class="line">    brelse(bh);</span><br><span class="line">    </span><br><span class="line">    rd_load();</span><br><span class="line">    mount_root();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="1-硬盘基本信息赋值"><a href="#1-硬盘基本信息赋值" class="headerlink" title="(1)硬盘基本信息赋值"></a>(1)硬盘基本信息赋值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> {</span><br><span class="line">    hd_info[<span class="number">0</span>].cyl = *(<span class="type">unsigned</span> <span class="type">short</span> *) BIOS;</span><br><span class="line">    hd_info[<span class="number">0</span>].head = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">2</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].wpcom = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">5</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].ctl = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">8</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].lzone = *(<span class="type">unsigned</span> <span class="type">short</span> *) (<span class="number">12</span>+BIOS);</span><br><span class="line">    hd_info[<span class="number">0</span>].sect = *(<span class="type">unsigned</span> <span class="type">char</span> *) (<span class="number">14</span>+BIOS);</span><br><span class="line">    BIOS += <span class="number">16</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/blk1.png" alt></p>
<h5 id="2-硬盘分区表设置"><a href="#2-硬盘分区表设置" class="headerlink" title="(2)硬盘分区表设置"></a>(2)硬盘分区表设置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> {</span></span><br><span class="line">    <span class="type">long</span> start_sect;</span><br><span class="line">    <span class="type">long</span> nr_sects;</span><br><span class="line">} hd[<span class="number">5</span>] = {}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sys_setup(<span class="type">void</span> * BIOS) {</span><br><span class="line">    ...</span><br><span class="line">    hd[<span class="number">0</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">    hd[<span class="number">0</span>].nr_sects = </span><br><span class="line">        hd_info[<span class="number">0</span>].head * hd_info[<span class="number">0</span>].sect * hd_info[<span class="number">0</span>].cyl;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> bread(<span class="number">0x300</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span> =</span> <span class="number">0x1BE</span> + (<span class="type">void</span> *)bh-&gt;b_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) {</span><br><span class="line">        hd[i].start_sect = p-&gt;start_sect;</span><br><span class="line">        hd[i].nr_sects = p-&gt;nr_sects;</span><br><span class="line">    }</span><br><span class="line">    brelse(bh);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>最终效果，就是给 hd 数组的五项附上了值，表示硬盘的分区信息，每个分区用 <strong>start_sect</strong> 和 <strong>nr_sects</strong>，也就是开始扇区和总扇区数来记录。分区信息在硬盘 0x1BE 偏移处，拿到这部分信息即可。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/hd.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> bread(<span class="number">0x300</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 从硬盘读取数据</span></span><br><span class="line"><span class="comment">// 0x300是第一块硬盘的主设备号</span></span><br><span class="line"><span class="comment">// 0 表示第一块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span> =</span> <span class="number">0x1BE</span> + (<span class="type">void</span> *)bh-&gt;b_data;</span><br><span class="line"><span class="comment">// 再取 0x1BE 偏移处，拿到分区信息</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/hdfq.png" alt></p>
<h5 id="3-虚拟内存盘执行"><a href="#3-虚拟内存盘执行" class="headerlink" title="(3)虚拟内存盘执行"></a>(3)虚拟内存盘执行</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd_load();</span><br></pre></td></tr></table></figure>
<p>有虚拟内存盘时候才会执行。</p>
<h5 id="4-根目录"><a href="#4-根目录" class="headerlink" title="(4)根目录"></a>(4)根目录</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount_root();</span><br></pre></td></tr></table></figure>
<p>加载根文件系统，有根文件系统后，OS才能从根开始找到所有存储在硬盘中的文件。</p>
<h3 id="2-加载根文件系统"><a href="#2-加载根文件系统" class="headerlink" title="2.加载根文件系统"></a>2.加载根文件系统</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> i,<span class="built_in">free</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">        file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[<span class="number">8</span>] ; p++) {</span><br><span class="line">        p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">        p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">        p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    p=read_super(<span class="number">0</span>);</span><br><span class="line">    mi=iget(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mi-&gt;i_count += <span class="number">3</span> ;</span><br><span class="line">    p-&gt;s_isup = p-&gt;s_imount = mi;</span><br><span class="line">    current-&gt;pwd = mi;</span><br><span class="line">    current-&gt;root = mi;</span><br><span class="line">    <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">    i=p-&gt;s_nzones;</span><br><span class="line">    <span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">            <span class="built_in">free</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">    i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line">            <span class="built_in">free</span>++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="1-硬盘中的文件系统格式"><a href="#1-硬盘中的文件系统格式" class="headerlink" title="(1)硬盘中的文件系统格式"></a>(1)硬盘中的文件系统格式</h4><p>linux0.11的文件系统是 <strong>MINIX</strong> 文件系统，与标准 UNIX 文件系统基本相同。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/wjxt.png" alt></p>
<p>·引导区：启动区，预留出来，保持格式统一。</p>
<p>·超级块：描述文件系统整体信息。</p>
<p>·inode位图和块位图：位图基本操作与使用。</p>
<p>·块：</p>
<p>​    普通文件<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewbox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"/></g></g></g></svg></mjx-container>二进制信息</p>
<p>​    目录类型<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewbox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"/></g></g></g></svg></mjx-container>目录文件、inode索引等信息</p>
<p>每一个块的结构大小是1024字节，即 1KB。写好操作系统后，给一个硬盘做某种文件系统类型的格式化，比如在安装<code>Arch Linux</code>时候，对硬盘格式化。这样就得到一个有文件系统的硬盘，然后OS可以成功启动。</p>
<h4 id="2-内存用于文件系统的数据结构"><a href="#2-内存用于文件系统的数据结构" class="headerlink" title="(2)内存用于文件系统的数据结构"></a>(2)内存用于文件系统的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> f_mode;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> f_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> f_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">f_inode</span>;</span></span><br><span class="line">    <span class="comment">// 包含文件大小、类型、所在硬盘块号</span></span><br><span class="line">    <span class="type">off_t</span> f_pos;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">        file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// file_table 表示进程使用的文件</span></span><br><span class="line">    <span class="comment">// f_count 表示被引用的次数，初始化为 0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[<span class="number">8</span>] ; p++) {</span><br><span class="line">        p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">        p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">        p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>super_block存在的意义：操作系统与一个设备以文件形式进行读写访问时，就需要把这个设备的超级块信息放在这里。通过这个超级块，可以掌握设备文件系统全局。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    p=read_super(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读取硬盘的超级块信息到内存中</span></span><br><span class="line">    mi=iget(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从设备上读取指定节点号的 i 节点</span></span><br><span class="line">    <span class="comment">//读取根 inode 信息,0是dev,1是nr(节点号)1</span></span><br><span class="line">    current-&gt;pwd = mi;</span><br><span class="line">    <span class="comment">//inode设置为当前进程的工作目录</span></span><br><span class="line">    current-&gt;root = mi;</span><br><span class="line">    <span class="comment">//inode设置为当前进程的根目录</span></span><br><span class="line">    i=p-&gt;s_nzones;</span><br><span class="line">    <span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">        set_bit(i&amp;<span class="number">8191</span>, p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data);</span><br><span class="line">    <span class="comment">//记录块位图信息</span></span><br><span class="line">    i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line">        set_bit(i&amp;<span class="number">8191</span>, p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data);</span><br><span class="line">    <span class="comment">//记录 inode 位图信息</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>整体上就是把硬盘中文件系统的各个信息，搬到内存中。</p>
<p>此时setup函数也结束，调用链如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    <span class="keyword">if</span> (!fork()) {</span><br><span class="line">        init();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(;;) pause();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">    <span class="comment">// setup 加载根文件系统，顺着根 inode 可以找到所有文件，就是为了下面 open 函数通过文件路径，从硬盘中拿到文件</span></span><br><span class="line">    (<span class="type">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">    (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">    (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_setup</span><span class="params">(<span class="type">void</span> * BIOS)</span> {</span><br><span class="line">    ...</span><br><span class="line">    mount_root();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="3-打开终端设备文件"><a href="#3-打开终端设备文件" class="headerlink" title="3.打开终端设备文件"></a>3.打开终端设备文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">    (<span class="type">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>open函数触发 0x80 中断，转到 sys_open 系统调用函数。</p>
<p>结论：进程 1 通过 open 函数建立了<strong>与外设交互</strong>的能力，具体其实就是打开了 tty0 这个设备文件，并绑定了标准输入 0，标准输出 1 和 标准错误输出 2 这三个文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">open.c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[64] =</span> {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> i,fd;</span><br><span class="line">    mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line"><span class="comment">//1.在进程文件描述符数组 filp 中找到一个空闲项，把空闲项的索引值记为 fd，每个进程最多打开 20 个文件</span></span><br><span class="line">    <span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;<span class="number">20</span>; fd++)</span><br><span class="line">        <span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (fd&gt;=<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line"><span class="comment">//2.在系统文件表 file_table 中找到空闲项，每个系统最多打开64个文件</span></span><br><span class="line">    f=<span class="number">0</span>+file_table;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;<span class="number">64</span> ; i++,f++)</span><br><span class="line">        <span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;=<span class="number">64</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">//3.将进程的文件描述符数组项和系统的文件表项对应起来</span></span><br><span class="line">    (current-&gt;filp[fd]=f)-&gt;f_count++;</span><br><span class="line"><span class="comment">//4.根据文件名从文件系统中找到对应文件</span></span><br><span class="line"><span class="comment">//相当于找到了 filename 文件对应的 inode 信息</span></span><br><span class="line">    i = open_namei(filename,flag,mode,&amp;inode);</span><br><span class="line"><span class="comment">//判断是否是字符设备</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line">        <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) {</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) {</span><br><span class="line">                current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">                tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) {</span><br><span class="line">                iput(inode);</span><br><span class="line">                current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">                f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -EPERM;</span><br><span class="line">            }</span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">        check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//5.填充 file 数据，即：初始化</span></span><br><span class="line">    f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">    f-&gt;f_flags = flag;</span><br><span class="line">    f-&gt;f_count = <span class="number">1</span>;<span class="comment">//引用次数为1</span></span><br><span class="line">    f-&gt;f_inode = inode;</span><br><span class="line">    f-&gt;f_pos = <span class="number">0</span>;<span class="comment">//文件读写指针为0</span></span><br><span class="line">    <span class="keyword">return</span> (fd);<span class="comment">//返回文件描述符</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/filp.png" alt></p>
<p>文件描述符</p>
<blockquote>
<p>文件描述符是一个用于表述<strong>指向文件引用</strong>的抽象化概念，在形式上是一个非负整数。 实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。在UNIX、Linux的系统调用中，大量的系统调用都是依赖于文件描述符。</p>
<p>文件描述符也有缺点：</p>
<p>在非UNIX/Linux 操作系统上（如Windows），无法基于这一概念进行编程——事实上，Windows下的<strong>文件描述符和信号量、互斥锁等内核对象</strong>一样都记作HANDLE。</p>
<p>由于文件描述符在形式上不过是个整数，当代码量增大时，会使编程者难以分清哪些整数意味着数据，哪些意味着文件描述符。因此，完成的代码可读性也就会变得很差，这一点一般通过使用名称有文字意义的 magic number 进行替换来解决。</p>
<p>摘自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">维基百科</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    setup((<span class="type">void</span> *) &amp;drive_info);</span><br><span class="line">    (<span class="type">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">    (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">    (<span class="type">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>open函数返回文件描述符为0号，作为<strong>标准输入设备</strong>:<code>stdin</code></p>
<p>复制文件描述符，产生文件描述符1号，作为<strong>标准输出设备</strong>:<code>stdout</code></p>
<p>复制文件描述符，产生文件描述符2号，作为<strong>标准错误输出设备</strong>:<code>stderr</code></p>
<p>dup函数：通过系统调用，到<code>sys_dup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从进程的 filp 中找到下一个空闲项，然后把要复制的文件描述符 fd 的信息，统统复制到这里。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_dup</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fildes)</span> {</span><br><span class="line">    <span class="keyword">return</span> dupfd(fildes,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd 是要复制的文件描述符</span></span><br><span class="line"><span class="comment">// arg 是指定新文件描述符的最小数值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dupfd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> arg)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (arg &lt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;filp[arg])</span><br><span class="line">            arg++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    (current-&gt;filp[arg] = current-&gt;filp[fd])-&gt;f_count++;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>进程 0 是不具备与外设交互的能力的，进程 1 刚刚创建的时候，是 fork 的进程 0，所以也不具备这样的能力，而通过 setup 加载根文件系统，open 打开 tty0 设备文件等代码，使得进程 1 具备了与外设交互的能力，同时也使得之后从进程 1 fork 出来的进程 2 也天生拥有和进程 1 同样的与外设交互的能力。具体可以体现为调用 printf 函数可以往屏幕上打印字符串了。</p>
<h3 id="4-进程2的创建"><a href="#4-进程2的创建" class="headerlink" title="4.进程2的创建"></a>4.进程2的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!(pid=fork())) {<span class="comment">//1.创建进程2</span></span><br><span class="line">        close(<span class="number">0</span>);		<span class="comment">//2.关闭 0 号文件描述符</span></span><br><span class="line">        open(<span class="string">"/etc/rc"</span>,O_RDONLY,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//3.打开 /etc/rc 文件，占据了 0 号文件描述符的位置</span></span><br><span class="line">        <span class="comment">//rc表示配置文件，与OS内核无关</span></span><br><span class="line">        execve(<span class="string">"/bin/sh"</span>,argv_rc,envp_rc);</span><br><span class="line">        _exit(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="5-execve-加载并执行-shell-程序"><a href="#5-execve-加载并执行-shell-程序" class="headerlink" title="5.execve 加载并执行 shell 程序"></a>5.execve 加载并执行 shell 程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], </span></span><br><span class="line"><span class="params">           <span class="type">char</span> *<span class="type">const</span> envp[])</span>; </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>execve</strong>() executes the program pointed to by <em>filename</em>. <em>filename</em> must be either a binary executable, or a script starting with a line of the form “<strong>#!</strong> <em>interpreter</em> [arg]”.</p>
<p>On success, <strong>execve</strong>() does not return, on error -1 is returned, and <em>errno</em> is set appropriately.</p>
</blockquote>
<p>execve()在当前进程的上下文中<strong>加载并运行一个新的程序</strong>，会覆盖当前进程的地址空间，但没有创建新进程。新程序仍然有相同的pid，并且继承了调用 execve 时已经打开的所有文件描述符。</p>
<p>写 linux 脚本时候，通常可以看到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br></pre></td></tr></table></figure>
<p>execve()判断前面两个字符是不是 <strong>#!</strong>，如果是的话，就走<strong>脚本文件</strong>的执行逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>,argv_rc,envp_rc);</span><br></pre></td></tr></table></figure>
<p>进程 2 通过 <strong>execve</strong> 函数，将自己摇身一变成为 <strong>/bin/sh</strong> 程序，也就是 <strong>shell</strong> 程序开始执行，下一条 CPU 指令会执行到 <code>/bin/sh</code>程序所在的内存起始位置处，即：<code>/bin/sh</code>头部结构中 <code>a_entry</code>所描述的地址。我们在 Linux 里执行一个程序，比如在命令行中 <code>./xxx</code>，其内部实现逻辑都是 <code>fork + execve</code> 这个原理。(shell就是这个原理)。</p>
<p>👋execve 是利用了中断、内存管理、文件系统、进程管理、可执行文件结构等多种底层知识结合起来的产物。<del>先挖个坑</del></p>
<h3 id="6-缺页中断"><a href="#6-缺页中断" class="headerlink" title="6.缺页中断"></a>6.缺页中断</h3><p>linux0.11中，每个进程是通过不同的局部描述符在线性地址空间中瓜分出不同的空间，一个进程占 64M。</p>
<p>缺页中断(Page fault)是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 CPU 的 MMU 所发出的中断。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/intel.png" alt></p>
<p>Page-Fault 在很多情况都会触发，具体是因为什么情况触发的，CPU 会帮我们保存在中断的出错码 <strong>Error Code</strong> 里。</p>
<p><img src="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/ERRORCODE.png" alt></p>
<p>触发缺页中断后，就会进入 Linux 0.11 源码中的 <strong>page_fault</strong> 方法，为了便于理解，选用 linux1.0 的代码，因为0.11的 <strong>page_fault</strong> 是用汇编写的，很不直观。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_page_fault</span><span class="params">(..., <span class="type">unsigned</span> <span class="type">long</span> error_code)</span> {</span><br><span class="line">    ...   </span><br><span class="line">    <span class="keyword">if</span> (error_code &amp; <span class="number">1</span>)</span><br><span class="line">        do_wp_page(error_code, address, current, user_esp);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        do_no_page(error_code, address, current, user_esp);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>当页表项 P 为0时，表示缺页，走<code>do_no_page</code>逻辑，程序简化后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memory.c</span></span><br><span class="line"><span class="comment">// address 缺页产生的线性地址 0x8000000(假设的)</span></span><br><span class="line"><span class="comment">// 也就是进程 2 自己线性地址空间的起始处 128M 这个位置</span></span><br><span class="line"><span class="comment">// 参数 error_code 是由 CPU 自动产生，address 是页面线性地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_no_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span> {</span><br><span class="line">    <span class="comment">// 1.线性地址的页面地址 0x8000000</span></span><br><span class="line">    <span class="comment">// 页表映射以页(4KB)为单位,进行内存对齐</span></span><br><span class="line">    address &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.计算 [相对] 于 [进程基址] 的偏移 </span></span><br><span class="line">    <span class="comment">// 对于进程2自己的偏移地址，要去掉段基址部分</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = address - current-&gt;start_code;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.寻找空闲的一页内存</span></span><br><span class="line">    <span class="comment">// 如果已经没有内存了，则返回 0。 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page = get_free_page();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.计算这个地址在文件中的哪个数据块 1</span></span><br><span class="line">    <span class="type">int</span> block = <span class="number">1</span> + tmp/BLOCK_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.一个数据块 1024 字节，一页内存 4096 字节</span></span><br><span class="line">    <span class="comment">// 所以一页内存需要读 4 个数据块</span></span><br><span class="line">    <span class="comment">// 把硬盘中的数据加载进内存</span></span><br><span class="line">    <span class="type">int</span> nr[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">4</span> ; block++,i++)</span><br><span class="line">        nr[i] = bmap(current-&gt;executable,block);</span><br><span class="line">    <span class="comment">// bmap 负责将相对于文件的数据块转换为相对于整个硬盘的数据块</span></span><br><span class="line">    <span class="comment">// 比如这个文件的第 1 块数据，可能对应在整个硬盘的第 24 块的位置</span></span><br><span class="line">    bread_page(page,current-&gt;executable-&gt;i_dev,nr);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 6.完成页表的映射,即建立相关页表</span></span><br><span class="line">    put_page(page,address);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>本质上就是加载硬盘对应位置的数据，然后建立页表的过程。</p>
<p>execve 函数返回后，CPU 就跳转到 <code>/bin/sh</code> 程序的第一行开始执行，但由于跳转到的线性地址不存在，所以引发<strong>缺页中断</strong>，把硬盘里 <code>/bin/sh</code> 所需要的内容加载到了内存，此时缺页中断返回。</p>
<p>缺页中断返回后，CPU 会尝试跳转到对应的线性地址，此时<strong>该线性地址已有对应的页表进行映射</strong>，所以顺利地映射到了物理地址，即<code>/bin/sh</code>的代码部分，可以开始执行<code>shell</code>程序。</p>
<h3 id="7-Shell-启动"><a href="#7-Shell-启动" class="headerlink" title="7.Shell 启动"></a>7.Shell 启动</h3><p><code>Shell = fork + execve</code></p>
<p>Shell代码不在 linux0.11 中，所以用<a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public/blob/master/sh.c">MIT的XV6源代码</a>学习一下原理即可。代码简化后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xv6-public sh.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 读取命令</span></span><br><span class="line">    <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>){</span><br><span class="line">        <span class="comment">// 创建新进程</span></span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 执行命令</span></span><br><span class="line">            runcmd(parsecmd(buf));</span><br><span class="line">        <span class="comment">// 等待进程退出</span></span><br><span class="line">        wait();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在死循环里面，shell 就是不断读取（<strong>getcmd</strong>）我们用户输入的命令，创建一个新的进程（<strong>fork</strong>），在新进程里执行（<strong>runcmd</strong>）刚刚读取到的命令，最后等待（<strong>wait</strong>）进程退出，再次进入读取下一条命令的循环中。</p>
<p>现在shell就已经启动了。</p>
<p>shell 程序有个特点，就是如果标准输入为一个普通文件，比如 /etc/rc，那么文件读取后就会使得 shell 进程退出，如果是字符设备文件，比如由我们键盘输入的 /dev/tty0，则不会使 shell 进程退出。</p>
<p>到此为止，整个OS就像这个样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 初始化环境</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 外层操作系统大循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 内层 shell 程序小循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 读取命令 read</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 创建进程 fork</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 执行命令 execve</span></span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>OS的本质就是靠各种中断驱动的死循环。</p>
<p>到此为止，OS启动完毕，本身设置好中断处理程序，随时等待中断到来，同时运行了shell程序用来接受用户的命令进行交互。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>后续要继续对Shell、execve等底层内容进行深入理解，到时候会新开post。</p>
<h1 id="附录-参考资料"><a href="#附录-参考资料" class="headerlink" title="附录 参考资料"></a>附录 参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.wikiwand.com/zh-sg/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/topics/computer-science/master-boot-record">Master Boot Record</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sunym1993/flash-linux0.11-talk">你管这破玩意叫操作系统源码 — 像小说一样品读 Linux 0.11 核心代码</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/">OSDEV</a></p>
<p><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html">Intel手册Vol.3A</a></p>

    </div>

    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>
        <div class="reward-container">
  <div>请作者喝一杯蜜雪冰城吧！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Nexus 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Nexus
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://nexuslbh.top/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" title="计算机是怎样跑起来的-linux0.11源代码学习">http://nexuslbh.top/2022/12/16/计算机是怎样跑起来的/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ComputerSystem/" rel="tag"><i class="fa fa-tag"></i> ComputerSystem</a>
          </div>
          <script type="text/javascript">
            var tagsall=document.getElementsByClassName("post-tags")
            for (var i = tagsall.length - 1; i >= 0; i--){
                var tags=tagsall[i].getElementsByTagName("a");
                for (var j = tags.length - 1; j >= 0; j--) {
                    var r=Math.floor(Math.random()*75+130);
                    var g=Math.floor(Math.random()*75+100);
                    var b=Math.floor(Math.random()*75+80);
                    tags[j].style.background = "rgb("+r+","+g+","+b+")";
                }
            }                        
          </script>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/11/%E8%B0%88%E8%B0%88BIOS/" rel="prev" title="谈谈BIOS">
      <i class="fa fa-chevron-left"></i> 谈谈BIOS
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/12/CSP-2209/" rel="next" title="CSP_2209">
      CSP_2209 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-boot%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">0x00 boot的含义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-BIOS"><span class="nav-number">2.</span> <span class="nav-text">0x01 BIOS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#step1-%E5%8A%A0%E7%94%B5%E8%87%AA%E6%A3%80"><span class="nav-number">2.1.</span> <span class="nav-text">step1 加电自检</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#step2-%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">step2 启动顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95-MBR"><span class="nav-number">3.</span> <span class="nav-text">0x02 主引导记录(MBR)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-MBR%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 MBR结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81%EF%BC%88%E8%B0%83%E7%94%A8OS%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">2.1.1启动代码（调用OS的机器码）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2%E5%88%86%E5%8C%BA%E8%A1%A8-Partition-Table"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.1.2分区表(Partition Table)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95%E7%AD%BE%E5%90%8D"><span class="nav-number">3.1.3.</span> <span class="nav-text">2.1.3主引导记录签名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-linux-0-11%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 linux_0.11源码讲解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-%E7%A1%AC%E7%9B%98%E8%BD%BD%E5%85%A5"><span class="nav-number">4.</span> <span class="nav-text">0x03 硬盘载入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86%E5%99%A8-boot-loader"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 启动管理器(boot loader)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%8D%B7%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95-Volume-boot-record"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 卷引导记录(Volume boot record)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%8B%93%E5%B1%95%E5%88%86%E5%8C%BA"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 拓展分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-linux-0-11%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 linux_0.11源码讲解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%8B%93%E5%B1%95%EF%BC%9Ax86%E6%9E%B6%E6%9E%84%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">4.5.</span> <span class="nav-text">3.5 拓展：x86架构的控制寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CR0%EF%BC%88%E5%B0%A4%E5%85%B6%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">4.5.1.</span> <span class="nav-text">CR0（尤其重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR1%EF%BC%88%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">4.5.2.</span> <span class="nav-text">CR1（未使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR2"><span class="nav-number">4.5.3.</span> <span class="nav-text">CR2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR3"><span class="nav-number">4.5.4.</span> <span class="nav-text">CR3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR4"><span class="nav-number">4.5.5.</span> <span class="nav-text">CR4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CR8"><span class="nav-number">4.5.6.</span> <span class="nav-text">CR8</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-OS%E5%86%85%E6%A0%B8%E8%BD%BD%E5%85%A5"><span class="nav-number">5.</span> <span class="nav-text">0x04 OS内核载入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8F%82%E6%95%B0%E5%8F%96%E5%80%BC%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="nav-number">5.1.</span> <span class="nav-text">1.参数取值与计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">2.各种初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BB%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86%E5%88%86%E9%85%8D-mem-init"><span class="nav-number">5.2.1.</span> <span class="nav-text">（1）主内存区管理分配 mem_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96-trap-init"><span class="nav-number">5.2.2.</span> <span class="nav-text">（2）中断初始化 trap_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%9D%97%E8%AE%BE%E5%A4%87%E8%AF%B7%E6%B1%82%E9%A1%B9%E5%88%9D%E5%A7%8B%E5%8C%96-blk-dev-init"><span class="nav-number">5.2.3.</span> <span class="nav-text">（3）块设备请求项初始化 blk_dev_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%9D%E5%A7%8B%E5%8C%96-tty-init"><span class="nav-number">5.2.4.</span> <span class="nav-text">（4）控制台初始化 tty_init</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rs-init"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">rs_init()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#con-init"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">con_init()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%97%B6%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96-time-init"><span class="nav-number">5.2.5.</span> <span class="nav-text">（5）时间初始化 time_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96-sched-init"><span class="nav-number">5.2.6.</span> <span class="nav-text">（6）进程调度初始化 sched_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96-buffer-init"><span class="nav-number">5.2.7.</span> <span class="nav-text">（7）缓冲区初始化 buffer_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E7%A1%AC%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96-hd-init"><span class="nav-number">5.2.8.</span> <span class="nav-text">（8）硬盘初始化 hd_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E6%89%93%E5%BC%80%E4%B8%AD%E6%96%AD-sti"><span class="nav-number">5.2.9.</span> <span class="nav-text">（9）打开中断 sti</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E8%BF%9B%E7%A8%8B0"><span class="nav-number">5.3.</span> <span class="nav-text">0x05 进程0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-number">5.3.1.</span> <span class="nav-text">（1）切换用户态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89fork%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">（2）fork创建进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83-tss"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">上下文环境 tss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF-counter"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">运行时间信息 counter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7-priority"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">优先级 priority</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-state"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">进程状态 state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">5.3.2.5.</span> <span class="nav-text">定时器与进程调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E8%BF%9B%E5%85%A5-fork"><span class="nav-number">5.3.2.6.</span> <span class="nav-text">正式进入 fork()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LDT%E8%B5%8B%E5%80%BC"><span class="nav-number">5.3.2.6.1.</span> <span class="nav-text">LDT赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.3.2.6.2.</span> <span class="nav-text">页表拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89pause-%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">5.3.3.</span> <span class="nav-text">（3）pause 死循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-Shell-%E7%99%BB%E5%9C%BA-init"><span class="nav-number">5.4.</span> <span class="nav-text">0x06 Shell 登场 - init</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A1%AC%E7%9B%98%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="nav-number">5.4.1.</span> <span class="nav-text">1.硬盘信息获取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-setup"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">sys_setup</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%A1%AC%E7%9B%98%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E8%B5%8B%E5%80%BC"><span class="nav-number">5.4.1.1.1.</span> <span class="nav-text">(1)硬盘基本信息赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.4.1.1.2.</span> <span class="nav-text">(2)硬盘分区表设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9B%98%E6%89%A7%E8%A1%8C"><span class="nav-number">5.4.1.1.3.</span> <span class="nav-text">(3)虚拟内存盘执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="nav-number">5.4.1.1.4.</span> <span class="nav-text">(4)根目录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8A%A0%E8%BD%BD%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.4.2.</span> <span class="nav-text">2.加载根文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%A1%AC%E7%9B%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">(1)硬盘中的文件系统格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E7%94%A8%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">(2)内存用于文件系统的数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">5.4.3.</span> <span class="nav-text">3.打开终端设备文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%BF%9B%E7%A8%8B2%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">5.4.4.</span> <span class="nav-text">4.进程2的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-execve-%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8C-shell-%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.4.5.</span> <span class="nav-text">5.execve 加载并执行 shell 程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="nav-number">5.4.6.</span> <span class="nav-text">6.缺页中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Shell-%E5%90%AF%E5%8A%A8"><span class="nav-number">5.4.7.</span> <span class="nav-text">7.Shell 启动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-number">6.</span> <span class="nav-text">后记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">附录 参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Nexus"
      src="/images/arch.png">
  <p class="site-author-name" itemprop="name">Nexus</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/NexusXDlbh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NexusXDlbh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3321861647@qq.com" title="E-Mail → mailto:3321861647@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/NexusLbh" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;NexusLbh" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      
      
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
          <h4 class="widget-title" style="font-size:20px;text-align:center;color:#0080FF;margin:20px 0 0px;">Tag Cloud</h4>
          <div id="myCanvasContainer" class="widget tagcloud" style="font-size:20px;">
              <canvas width="220" height="200" id="resCanvas" style="width=100%">
                  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSer/" rel="tag">CSer</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ComputerSystem/" rel="tag">ComputerSystem</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBase/" rel="tag">DataBase</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataStructure-and-Algorithm/" rel="tag">DataStructure and Algorithm</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ML/" rel="tag">ML</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/" rel="tag">Math</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEC/" rel="tag">SEC</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Search/" rel="tag">Search</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/University/" rel="tag">University</a><span class="tag-list-count">4</span></li></ul>
              </canvas>
          </div>
      </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>




      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nexus</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">450k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:49</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'NLtLmA6YQidughGHtg1RBkvk-gzGzoHsz',
      appKey     : 'VdYpKRx5SPqTdAIEf3XpsmAp',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>

