<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>后量子密码-格密码学 | Meta Field</title><meta name="author" content="NexusLbh"><meta name="copyright" content="NexusLbh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="后量子密码-格密码学一.后量子密码0x01 什么是后量子密码后量子密码是能够抵抗量子计算机对现有密码算法攻击的 新一代密码算法。 所谓“后”，是因为量子计算机的出现，现有的绝大多数公钥密码算法（$RSA$、$Diffie-Hellman$、椭圆曲线等）能被足够大和稳定的量子计算机攻破，所以可以抵抗这种攻击的密码算法可以在量子计算和其之后时代存活下来，所以被称为“后”量子密码。英文表述是：”Post">
<meta property="og:type" content="article">
<meta property="og:title" content="后量子密码-格密码学">
<meta property="og:url" content="http://nexuslbh.top/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/index.html">
<meta property="og:site_name" content="Meta Field">
<meta property="og:description" content="后量子密码-格密码学一.后量子密码0x01 什么是后量子密码后量子密码是能够抵抗量子计算机对现有密码算法攻击的 新一代密码算法。 所谓“后”，是因为量子计算机的出现，现有的绝大多数公钥密码算法（$RSA$、$Diffie-Hellman$、椭圆曲线等）能被足够大和稳定的量子计算机攻破，所以可以抵抗这种攻击的密码算法可以在量子计算和其之后时代存活下来，所以被称为“后”量子密码。英文表述是：”Post">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d6ppwl.jpg">
<meta property="article:published_time" content="2023-01-17T09:32:00.000Z">
<meta property="article:modified_time" content="2023-01-17T09:33:19.272Z">
<meta property="article:author" content="NexusLbh">
<meta property="article:tag" content="SEC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/d6/wallhaven-d6ppwl.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://nexuslbh.top/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '后量子密码-格密码学',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-17 17:33:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/d6/wallhaven-d6ppwl.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Meta Field"><span class="site-name">Meta Field</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">后量子密码-格密码学</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-17T09:32:00.000Z" title="发表于 2023-01-17 17:32:00">2023-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-17T09:33:19.272Z" title="更新于 2023-01-17 17:33:19">2023-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="后量子密码-格密码学"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="后量子密码-格密码学"><a href="#后量子密码-格密码学" class="headerlink" title="后量子密码-格密码学"></a>后量子密码-格密码学</h1><h2 id="一-后量子密码"><a href="#一-后量子密码" class="headerlink" title="一.后量子密码"></a>一.后量子密码</h2><h3 id="0x01-什么是后量子密码"><a href="#0x01-什么是后量子密码" class="headerlink" title="0x01 什么是后量子密码"></a>0x01 什么是后量子密码</h3><p>后量子密码是能够抵抗量子计算机对现有密码算法攻击的 <strong>新一代密码算法</strong>。</p>
<p>所谓“后”，是因为量子计算机的出现，现有的绝大多数公钥密码算法（$RSA$、$Diffie-Hellman$、椭圆曲线等）能被足够大和稳定的量子计算机攻破，所以可以抵抗这种攻击的密码算法可以在量子计算和其之后时代存活下来，所以被称为“后”量子密码。英文表述是：”Post-quantum Cryptography (PQC)”，或者 “Quantum-resistant cryptography”。</p>
<p>后量子密码，作为未来 5-10 年逐渐代替 $RSA$、$Diffie-Hellman$、椭圆曲线等现行公钥密码算法的密码技术，正被越来越多的人所了解。目前，美国国家标准技术研究所 ($NIST$) 正在制定的新一代密码技术标准，正是后量子密码标准。</p>
<h3 id="0x02-为什么需要后量子密码"><a href="#0x02-为什么需要后量子密码" class="headerlink" title="0x02 为什么需要后量子密码"></a>0x02 为什么需要后量子密码</h3><p>时至2022年，计算机与互联网领域广泛使用的公钥加密算法均基于三个计算难题：整数分解问题、离散对数问题或椭圆曲线离散对数问题，如DH、ECDH、RSA、ECDSA。然而，这些难题均可使用量子计算机并应用<strong>秀尔算法</strong>破解。虽然人类目前还不具备建造如此大型量子计算机的科学技术（5量子比特的量子计算机造价在千万美元左右），但其<strong>安全隐患</strong>已经引起了学术研究者和政府机构的担忧。</p>
<p>设想有两个敌对国家，其中一国秘密发展了量子计算机，而另一国还在使用普通电子计算机的密码体系。如果前者利用量子计算机对后者的密码体系发动攻击， 那么后者的信息安全体系将会瞬间崩溃。 </p>
<p>许多密码学家都在未雨绸缪，研发全新的公钥加密算法以应对将来的威胁。1994 年，当代著名数学家和计算机科学家<strong>彼得·肖尔</strong>首次提出了大整数分解的多项式时间量子算法，并应用于密码学。<strong>他的工作表明，在量子计算时代，基于大整数分解和离散对数问题的公钥密码体系将被攻破。</strong>自第一届后量子密码学大会于2006年开办以来，本领域的研究工作愈发活跃，已成为学术和业界的关注焦点。</p>
<p>2015 年 8 月，美国国家安全局（NSA）宣布美国政府决定制定下一代抗量子密码标准，且“刻不容缓”。2016 年，美国国家标准与技术研究院（NIST） 向全世界征集抵抗量子计算机攻击的后量子密码标准。历经 4 轮遴选淘汰， 2022 年 7 月 5 日 NIST 公布了 4 项后量子密码标准。<strong>其中 3 项基于格理论、1 项基于编码理论。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">密码算法</th>
<th style="text-align:center">量子计算的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">对称密码算法(SM4,AES)</td>
<td style="text-align:center">密钥加倍（Grover）</td>
</tr>
<tr>
<td style="text-align:center">散列函数(SM3,SHA-3)</td>
<td style="text-align:center">输出长度增加（Grover）</td>
</tr>
<tr>
<td style="text-align:center">经典公钥算法(RSA,DSA,ECC)</td>
<td style="text-align:center">多项式算法（Shor）</td>
</tr>
<tr>
<td style="text-align:center">格密码</td>
<td style="text-align:center">未找到有效算法</td>
</tr>
<tr>
<td style="text-align:center">多变量密码（数字签名）</td>
<td style="text-align:center">未找到有效算法</td>
</tr>
<tr>
<td style="text-align:center">基于Hash的密码（数字签名）</td>
<td style="text-align:center">未找到有效算法</td>
</tr>
<tr>
<td style="text-align:center">基于编码的密码（加密）</td>
<td style="text-align:center">未找到有效算法</td>
</tr>
<tr>
<td style="text-align:center">超奇异同源</td>
<td style="text-align:center">未找到有效算法</td>
</tr>
</tbody>
</table>
</div>
<h3 id="0x03-后量子密码算法实现途径"><a href="#0x03-后量子密码算法实现途径" class="headerlink" title="0x03 后量子密码算法实现途径"></a>0x03 后量子密码算法实现途径</h3><p>ⅰ. 格 (Lattice-based) <strong>最通用</strong>的一类，几乎所有经典密码概念都可以在格密码中实现，由于其计算速度快、通信开销较小，且能被用于构造各类密码学算法和应用，因此被认为是<strong>最有希望的后量子密码技术</strong>。是在算法构造本身或其安全性证明中应用到格的密码学。格，又称<strong>点阵</strong>，是群论中的数学对象，可以直观地理解为空间中的点以固定间隔组成的排列，它具有周期性的结构。更准确地说，是在 n 维空间 $R^{n}$ 中加法群的离散子群，这一数学对象有许多应用，其中存在几个称为“格问题”的难题，如 最短向量问题 和 最近向量问题。许多基于格的密码系统利用到了这些难题。</p>
<p>ⅱ. 编码(Code-based) 主要用于构造加密算法。代表算法：McEliece。首次发表于1978年（仅比RSA晚一年），使用的是<strong>二元戈帕码</strong>，经历了三十多年的考验，至今仍未能破解。但<strong>缺点是公钥体积极大</strong>，一直没有被主流密码学界所采纳。但随着后量子密码学提上日程，McEliece算法又重新成为了候选者。许多研究者尝试将二元戈帕码更换为其他纠错码，如里德-所罗门码、LDPC等，试图降低密钥体积，但全部遭到破解，而原始的二元戈帕码仍然安全。</p>
<p>ⅲ. 多变量(Multivariate-based) 构造签名方案、加密、密钥交换较有优势。是应用了有限域 $F$ 上多元多项式的密码学，包括对称加密和非对称加密。</p>
<p>ⅳ. 哈希(Hash-based) 主要用于构造数字签名。代表算法：Merkle 哈希树签名、XMSS、Lamport 签名等。</p>
<p>这些算法的安全性，<strong>依赖于有没有可以 快速求解其底层数学问题 或 直接对算法本身的高效攻击算法 </strong>。这也正是量子计算机对于公钥密码算法有很大威胁的原因。</p>
<h3 id="0x04-后量子密码应用现状"><a href="#0x04-后量子密码应用现状" class="headerlink" title="0x04 后量子密码应用现状"></a>0x04 后量子密码应用现状</h3><p>后量子密码可以被应用于更高层次一些的协议/应用，包括：HTTPS (TLS)、SSH、VPN、IPsec、比特币等数字货币、U 盾、桌面/移动操作系统等各个领域中。</p>
<p>最著名的是 <a target="_blank" rel="noopener" href="https://security.googleblog.com/2016/07/experimenting-with-post-quantum.html">2016 年 Google 在 Chrome Canary 分支版本中加入了 基于 RLWE 问题的后量子密钥交换算法 NewHope</a> 。</p>
<p><img src="/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/go.png" style="zoom:80%;"></p>
<p>加密算法：</p>
<ul>
<li>CRYSTALS-KYBER：基于格密码（Structured-lattices）</li>
</ul>
<p>签名算法：</p>
<ul>
<li>CRYSTALS-DILITHIUM：基于格密码</li>
<li>FALCON：基于格密码（Structured-lattices）</li>
<li>SPHINCS+：基于哈希函数（Structured-lattices）</li>
</ul>
<p>微软研究院：</p>
<ul>
<li><p>推出 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/PQCrypto-VPN">后量子 VPN</a></p>
<p>  <img src="/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/hlzpng.png" style="zoom:75%;"></p>
</li>
<li><p>将其主推的后量子密码算法 Picnic 使用到 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30136885">PKI</a>(Public Key Infrastructure，公开密钥基础设施) 和 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/481881911">HSM</a>(Hardware Security Module，硬件安全模块) 集群中。</p>
</li>
</ul>
<h2 id="二-格密码学"><a href="#二-格密码学" class="headerlink" title="二.格密码学"></a>二.格密码学</h2><p>格密码是一类备受关注的抗量子计算攻击的公钥密码体制. 格密码理论的研究涉及的密码数学 问题很多, 学科交叉特色明显, 研究方法趋于多元化。</p>
<p>格密码的发展大体分为两条主线: 一是从具有悠久 历史的格经典数学问题的研究发展到近 30 多年来高维格困难问题的求解算法及其计算复杂性理论研究;  二是从使用格困难问题的求解算法分析非格公钥密码体制的安全性发展到基于格困难问题的密码体制的设计。</p>
<h3 id="0x11-格密码简史"><a href="#0x11-格密码简史" class="headerlink" title="0x11 格密码简史"></a>0x11 格密码简史</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">标志事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">18世纪–1982年</td>
<td style="text-align:center">格经典数学问题的讨论，代表人物：Lagrange，Gues，Hermite，MInkowski等</td>
</tr>
<tr>
<td style="text-align:center">1982年–1996年</td>
<td style="text-align:center">LLL算法的提出（Lenstra-Lenstra-Lovasz）</td>
</tr>
<tr>
<td style="text-align:center">1996年–2005年</td>
<td style="text-align:center">第一代格密码诞生（Ajtai96, AD97G, GH9）</td>
</tr>
<tr>
<td style="text-align:center">2005年–2016年</td>
<td style="text-align:center">第二代格密码出现并逐步完善，并实用化格密码算法 （Regev05, GPV08,MP12 BLISS ,NewHope, Frodo）</td>
</tr>
<tr>
<td style="text-align:center">2016年–</td>
<td style="text-align:center">格密码逐步得以标准化</td>
</tr>
</tbody>
</table>
</div>
<h3 id="0x12-格密码优势"><a href="#0x12-格密码优势" class="headerlink" title="0x12 格密码优势"></a>0x12 格密码优势</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格密码</th>
<th style="text-align:center">经典密码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">量子攻击算法</td>
<td style="text-align:center">Shor算法</td>
</tr>
<tr>
<td style="text-align:center">矩阵乘法、多项式乘法</td>
<td style="text-align:center">Shor算法</td>
</tr>
<tr>
<td style="text-align:center">Worst-case hardness</td>
<td style="text-align:center">Average-case hardnes</td>
</tr>
<tr>
<td style="text-align:center">结构灵活、功能丰富</td>
<td style="text-align:center">结构简单、功能受限</td>
</tr>
</tbody>
</table>
</div>
<h3 id="0x13-格密码发展"><a href="#0x13-格密码发展" class="headerlink" title="0x13 格密码发展"></a>0x13 格密码发展</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">post</th>
<th style="text-align:center"></th>
<th style="text-align:center">current</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">格经典数学问题</td>
<td style="text-align:center">$\to$</td>
<td style="text-align:center">高维格困难问题的求解算法及其计算复杂性理论研究</td>
</tr>
<tr>
<td style="text-align:center">使用 格困难问题的求解算法 分析 非格公钥密码体制的安全性</td>
<td style="text-align:center">$\to$</td>
<td style="text-align:center">基于格困难问题的密码体制的设计</td>
</tr>
</tbody>
</table>
</div>
<h3 id="0x14-格基本概念-Lattice"><a href="#0x14-格基本概念-Lattice" class="headerlink" title="0x14 格基本概念(Lattice)"></a>0x14 格基本概念(Lattice)</h3><p><strong>1. 线性无关</strong></p>
<p>$v<em>1,\dots,v_n$ 其中任何一个向量 $v_i$ 都不是它前面的$v_1,\dots,v</em>{i-1}$ 的向量组合，即存在一组数 $k_1,k_2,\dots,k_n$ 使得 $k_1v_1+k_2v_2+\dots+k_nv_n=0$ 且 $k_i = 0 , 1 \leq i \leq n$ 。当这组数不全为0时，线性相关。</p>
<p>线性无关的性质：</p>
<p>性质1：若两个向量组 $(1)\alpha_1,\alpha_2,\dots,\alpha_r;(2)\beta_1,\beta_2,\dots,\beta_s$ ,(1)中任意向量可由(2)线性表示，(2)中任意向量可由(1)线性表示，那么这两个向量组等价。</p>
<p>性质2：向量组 $\alpha_1,\alpha_2,\dots,\alpha_m$线性无关，$\beta,\alpha_1,\alpha_2,\dots,\alpha_m$线性相关，则 $\beta$ 可由 $\alpha_1,\alpha_2,\dots,\alpha_m$ 线性表示 且 表示式唯一。</p>
<p><strong>2. 定义</strong></p>
<p>设 $v_1,\dots,v_n \in R^{m}$ 是一组<strong>线性无关</strong>的向量。由 $v_1,\dots,v_n$生成的格 $L$ 是指 向量 $v_1,\dots,v_n$ 的线性组合构成的<strong>向量集合</strong>，且其所使用的系数 $a_i$ 均在 $Z^{n}$ 中，即：</p>
<script type="math/tex; mode=display">
L = \{a_1v_1+a_2v_2+\dots+a_nv_n:a_1,a_2,\dots,a_n \in Z \}</script><p>严格地说，格是m维欧式空间 $R^{m}$ 的$n$个线性无关向量组 $v_1,\dots,v_n \in R^{m}$的所有整系数线性组合。</p>
<p><strong>3. 基 与 维度</strong></p>
<p>任意一组可以生成格的线性无关的向量都称为<strong>格的基</strong>，格的基中的向量个数称为<strong>格的维度</strong>。<strong>某种程度上，格可以理解成系数为整数的向量空间。</strong>简单来说，对于二维坐标系，向量 $(1,0)$ 和 $(0,1)$ 就是最简单的一组格基。一般来说，达到足够安全性的方案，格的维度在 1000 左右。</p>
<p><strong>4. Hadamard比率</strong></p>
<p>用来描述 n 维线性空间某一组基 $B = {b_1,b_2,\dots,b_n }$ 的正交程度，其中 $det(·)$ 是行列式，$||·||$是L2范数，$| ·|$是绝对值。越接近 1，基B的正交性越好，若等于 1，那么B是正交基。</p>
<script type="math/tex; mode=display">
H(B):=\frac{|det(B)|}{\prod \limits_{i=1}^n||b_i||} \quad ,\quad 0<H(B)\leq 1</script><p><strong>5. Gram_Schmidt正交化 (施密特正交化)</strong></p>
<p>正交：非0向量内积为0，即</p>
<script type="math/tex; mode=display">
[x,y] = x^{T}y = 0</script><p>标准正交基：向量 $q_1,q_2,\dots,q_n$是标准正交的，当且仅当</p>
<script type="math/tex; mode=display">
q_i^{T}q_j = \left\{
\begin{aligned}
0,if \quad i \neq j (正交向量)\\
1,if \quad i = j(单位向量)
\end{aligned}
\right.</script><p>Schmit正交化：给定 n 个线性无关向量 $b_1,b_2,\dots,b_n \in R^{n}$，被定义为</p>
<script type="math/tex; mode=display">
\widetilde b_i:=b_i-\sum_{j=1}^{i-1}\mu_{ij}\widetilde b_{j}, \,where \quad \mu_{i,j} = \frac{<b_i,\widetilde b_j>}{<\widetilde b_j,\widetilde b_j>}</script><p>此处写一下三维的施密特正交公式：</p>
<script type="math/tex; mode=display">
\beta_1 = \alpha_1 \\
\beta_2 = \alpha_2 - \frac{(\beta_1,\alpha_2)}{(\beta_1,\beta_1)} \beta_1 \\
\beta_3 = \alpha_3 - \frac{(\beta_1,\alpha_3)}{(\beta_1,\beta_1)}\beta_1 - \frac{(\beta_2,\alpha_3)}{(\beta_2,\beta_2)}\beta_2</script><p><strong>6. 约减基</strong></p>
<p>约减的主要目的是<strong>将这组任意给定的基转化为一组正交性较好的优质基</strong>，并使得这个优质基中的各个向量尽量短。</p>
<p>如果以下情况成立，基 $B={b_1,\dots,b_n} \in  \mathbb{R}^{n}$是一个 $\delta - LLL$约减基:</p>
<script type="math/tex; mode=display">
1. \begin{flalign} \quad\forall 1 \leq i \leq n, j < i ,|\mu_{i,j}| \leq \frac{1}{2} \end{flalign} \\ 
2.\quad\forall 1\leq i < n , \delta ||\widetilde b_i||^2 \leq ||\mu_{i+1,i} \widetilde b_i + \widetilde b_{i+1} ||^2</script><p>根据施密特正交，可以看出 $\mu_{i,j}$与两个基向量的夹角有关。</p>
<p><strong>7.素数有限域 $\mathbb{Z_{q}}$</strong></p>
<p>即我们的世界里面只存在 $(-q/2,q/2)$ 这个范围内所有整数。</p>
<p><strong>8.无限范数(Infinity Norm)</strong> $||e \in \mathbb{Z<em>{q}^{m}}||</em>{\infty}$</p>
<p>$||e||<em>{\infty} = max</em>{i}^{m}|e_i|$，即：找这个维度为 m 的向量 e 中的每一个值，然后返回最大值。</p>
<p><strong>9.最大值封顶的随机分布</strong> $x_{B}$</p>
<p>从这个随机分布中取出的每一个随机值都小于 B 。</p>
<script type="math/tex; mode=display">
\forall x \gets x_{B}^{m}:|| x ||_{\infty} \leq B</script><h3 id="0x15-格的困难数学问题"><a href="#0x15-格的困难数学问题" class="headerlink" title="0x15 格的困难数学问题"></a>0x15 格的困难数学问题</h3><p>密码学方案的安全性的一个重要条件是：底层的数学问题是困难的。对于格密码，自然就是格中的困难问题需要是真正困难的，所以研究格问题的困难性是很重要的研究方向。</p>
<p>✍最短向量问题(<strong>Shortest Vector Problem,SVP</strong>)</p>
<p>对于给定的格 $L$ ，找到非零的格向量 $v$ ，使得对于任意非零向量 $u \in L , ||v|| \leq ||u||$</p>
<p>✍近似最短向量问题(<strong>Approximate Shortest Vector Problem,aSVP</strong>)</p>
<p>对于给定的格 $L$ ，找到非零的格向量 $v$ ，使得对于任意非零向量 $u \in L , ||v|| \leq \gamma ||u||,\gamma \geq 1$</p>
<p>✍唯一最短向量问题(<strong>Unique Shortest Vector Problem,uSVP</strong>)</p>
<p>对于给定的格 $L$ ，满足 $\lambda<em>{2}(L) \gt \gamma \lambda</em>{1}(L)$，找到格的最短向量</p>
<p>✍近似最短向量判断问题(<strong>GapSVP</strong>)</p>
<p>对于给定的格 L 和有理数 r，如果有 $\lambda<em>{1}(L) \leq r$，则返回<strong>是</strong>；如果 $\lambda</em>{1}(L) \leq \gamma r$，则返回<strong>否</strong>。其它情况随机返回 <strong>是</strong> 或 <strong>否</strong>。</p>
<p>✍小整数问题(<strong>SIS</strong>)</p>
<p>给定模数 $q\ge1$ ，常实数$v$和矩阵$A \in Z_{q}^{n\times m}$，其中$m \ge n \gt 0$。如何寻找一个非零向量 $u \in Z^{m}$，使得 $Au=0 \,mod\, q$ 且 $||u|| \leq v$。</p>
<p>✍搜索型误差学习(<strong>LWE</strong>)</p>
<p>给定一个维数 $n\ge1$，模数 $q\ge 1$，$Z<em>q$ 上一概率分布为 X。随机从分布 $Z</em>{q}^{n} \times Z<em>{q}$ 中均匀抽样或者 $A</em>{s,X}$ 中独立抽样，如果判断此抽样来自 $A<em>{s,X}$则返回 “YES” ，如果来自  $Z</em>{q}^{n} \times Z_{q}$ 返回 “NO”。</p>
<h3 id="0x16-高斯格基约减算法-Gauss-Lattice-Reduction"><a href="#0x16-高斯格基约减算法-Gauss-Lattice-Reduction" class="headerlink" title="0x16 高斯格基约减算法(Gauss Lattice Reduction)"></a>0x16 高斯格基约减算法(Gauss Lattice Reduction)</h3><p>此算法是二维情况，思想和 LLL 有相似之处，都是不断实施<strong>先约化后交换</strong>的策略。</p>
<p>对于 $v_1,v_2$ 两个向量，满足$|| v_1 || \lt || v_2 ||$；如果 $||v_1|| &gt; || v_2||$ ，则交换 $v_1$ 和 $v_2$。$v_2^* = v_2 - mv_1,m = [\frac{<v_1,v_2>}{||v_1||^2}]$。这个想法基于Schmit正交化，为了满足格的整系数条件做了系数四舍五入的处理。</v_1,v_2></p>
<p>算法步骤：</p>
<p><img src="/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/wdm.png" style="zoom: 80%;"></p>
<p>m=0 时约化结束，下面证明最后返回的 $v_1$ 是格中最短向量，此时满足 $|\frac{<v_1,v_2>}{||v_1||^2}| \leq 0.5 $。</v_1,v_2></p>
<p>设 $v = av_1 + bv_2(ab \neq 0)$</p>
<script type="math/tex; mode=display">
\begin{align*}
||v||^2 &= a^2||v_1||^2 + b^2||v_2||^2 + 2ab<v_1,v_2> \\
&\ge a^2|| v_1 ||^2 + b^2||v_2||^2 - 2ab<v_1,v_2> \\
&\ge a^2|| v_1||^2 - ab||v_1||^2 + b^2||v_1||^2 \\ &= (a^2-ab+b^2)||v_1||^2 \\
&a^2 - ab + b^2 = (a-\frac{1}{2}b)^2 + \frac{3}{4}b^2
\end{align*}</script><p>上式必为非负整数，当且仅当 $a=b=0$ 时等式左右相等，故</p>
<script type="math/tex; mode=display">
||v|| \geq ||v_1||</script><p>算法递归实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Gauss_Reduction</span>(<span class="params">v1,v2</span>):</span><br><span class="line">    <span class="keyword">if</span> v1.norm() &gt; v2.norm():</span><br><span class="line">        v1,v2 = v2,v1</span><br><span class="line">    m = <span class="built_in">round</span>((v1*v2)/v1.norm()^<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> : <span class="keyword">return</span> (v1,v2)</span><br><span class="line">    <span class="keyword">else</span> : </span><br><span class="line">        v2 = v2 - m*v1 </span><br><span class="line">        <span class="keyword">return</span> Gauss_Reduction(v2,v1)</span><br></pre></td></tr></table></figure>
<p>算法循环实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Gauss_Algorithm</span>(<span class="params">x,y</span>):</span><br><span class="line">    v1 = x; v2 = y</span><br><span class="line">    finish = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> finish:</span><br><span class="line">        m = <span class="built_in">round</span>(v2.dot_product(v1)/v1.dot_product(v1))</span><br><span class="line">        v2 = v2 - m*v1</span><br><span class="line">        <span class="keyword">if</span>(v1.norm() &lt;= v2.norm()):</span><br><span class="line">            finish = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>: v1,v2 = v2,v1</span><br><span class="line">    <span class="keyword">return</span> v1,v2 </span><br></pre></td></tr></table></figure>
<h3 id="0x17-LLL算法"><a href="#0x17-LLL算法" class="headerlink" title="0x17 LLL算法"></a>0x17 LLL算法</h3><p>LLL算法是最短向量问题(SVP)的近似算法，是1982年由K.Lenstra, H.W.Lenstra, Jr. and L.Lovasz 设计的，后被称为LLL算法，给出了一个 $(\frac{2}{\sqrt3})^{n}$ 的近似比例 (approximation ratio)，其中 $n$ 是格的维数。 </p>
<p>LLL 算法可以看作是高斯约减算法在高维情况下的推广，本质是：<strong>把给定的向量基转化为一组正交性较好的优质基，并使得这个优质基中的各个向量尽可能短。</strong></p>
<p>首先用矩阵形式描述 <strong>Schmit正交化</strong> 过程。</p>
<script type="math/tex; mode=display">
(v_1\,v_2\,\dots\,v_n)=(v_1^*\,v_2^*\,\dots v_n^*)*
\begin{bmatrix}
 1 & u_{1,2} & u_{1,3} & \dots & u_{1,n} \\
     & 1 &u_{2,3} & \dots & u_{2,n} \\
     &   &          & \dots &         \\
     &   &        &       & 1
\end{bmatrix} \\
u_{i,j} = \frac{<v_i^*,v_j>}{||v_i^*||^2}</script><p>令${v<em>1,v_2,\dots,v</em>{n}}$为格$L$的一组基，$LLL$算法可以在有限步骤内终止，并且能返回L的一组$LLL$约减基，检测到满足条件后直接输出。</p>
<p>​    1.size<em>reduce：任意 $i&lt;j \leq n , |u</em>{i,j}| \leq 0.5$</p>
<p>​    2.Lovász condition：$||v<em>i^*||^2 \geq (\frac{3}{4}-u</em>{i-1,i}^2)||v_{i-1}||^2$</p>
<p>注：对于 Lovász condition 可以有多种表达式，另一种常见且正确的表达式为</p>
<script type="math/tex; mode=display">
||v_i^* + \mu_{i,i-1}v_{i-1}^*||^2 \ge \frac{3}{4}||v_{i-1}^*||^2</script><p><img src="/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/lll.png" style="zoom:67%;"></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LLL_v0</span>(<span class="params">M, delta=<span class="number">0.75</span></span>):</span><br><span class="line">    B = deepcopy(M)</span><br><span class="line">    Q, mu = B.gram_schmidt()</span><br><span class="line">    n, k = B.nrows(), <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># size reduction step</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(k)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>( mu[k][j] ) &gt; <span class="number">0.5</span>:</span><br><span class="line">                B[k] = B[k] - <span class="built_in">round</span>( mu[k][j] ) * B[j]</span><br><span class="line">                Q, mu = B.gram_schmidt()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># swap step </span></span><br><span class="line">        <span class="keyword">if</span> Q[k].dot_product(Q[k]) &gt;= (delta - mu[k][k-<span class="number">1</span>]^<span class="number">2</span>) * Q[k-<span class="number">1</span>].dot_product(Q[k-<span class="number">1</span>]):</span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            B[k], B[k-<span class="number">1</span>] = B[k-<span class="number">1</span>], B[k]</span><br><span class="line">            Q, mu = B.gram_schmidt()</span><br><span class="line">            k = <span class="built_in">max</span>(k-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> B </span><br></pre></td></tr></table></figure>
<p>经过LLL格约减算法后得到的一组基有着一些良好的性质，这组基可以在多项式时间内得到，利用这些性质我们可以很容易地求解某些问题，例如，通过使用LLL格约减算法可以在一个令密钥持有者十分不安的时间内，破解那些使用基于背包密码体制问题的密码系统密钥。</p>
<p>LLL算法复杂度：</p>
<script type="math/tex; mode=display">
log_{\frac{1}{\sqrt\delta}}D_{B} \leq \frac{1}{log\, 1 / \sqrt(\delta)} · \frac{n(n-1)}{2}·log(max||b_i||)</script><p>LLL算法与欧几里得算法的联系：</p>
<blockquote>
<p>LLL often gets compared to Euclid’s Algorithm for finding GCDs. This is an imperfect analogy, but at a high-level they have a core similarity. Namely, both LLL and Euclid’s algorithm could be broken down into two steps: “reduction” and “swap”.</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">euclid_gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>: <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">return</span> a </span><br><span class="line">    x = a mod b <span class="comment"># reduction step </span></span><br><span class="line">    <span class="keyword">return</span> euclid_gcd(b, x) <span class="comment"># swap step</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dont try to grok this yet...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lll</span>(<span class="params">basis</span>):</span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> reverse(<span class="built_in">range</span>(k-<span class="number">1</span>, <span class="number">0</span>)): <span class="comment"># reduction step loop</span></span><br><span class="line">            m = mu(k,j)</span><br><span class="line">            basis[k] = basis[k] - mu*basis[j] <span class="comment"># vector reduction</span></span><br><span class="line">            <span class="comment"># update orthogonalized basis </span></span><br><span class="line">    <span class="keyword">if</span> lovasz_condition:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        basis[k], basis[k+<span class="number">1</span>] = basis[k+<span class="number">1</span>], basis[k] <span class="comment"># swap step</span></span><br><span class="line">        <span class="comment"># update orthogonalized basis</span></span><br><span class="line">        k = <span class="built_in">max</span>(k-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> basis</span><br></pre></td></tr></table></figure>
<h3 id="0x18-LWE-Learning-With-Errors"><a href="#0x18-LWE-Learning-With-Errors" class="headerlink" title="0x18 LWE(Learning With Errors)"></a>0x18 LWE(Learning With Errors)</h3><p>1.有噪声的高斯消除问题(<strong>Gaussian Elimination with Noise</strong>)</p>
<p>线性代数我们学了，高斯消除法是在行与行之间操作求解未知数的方法，即：给定一个矩阵 $A$ 和一个向量 $b$，能否找到一个向量 $x$ ，使得 $Ax = b$ 关系满足。</p>
<p>增加噪声后，问题变为：</p>
<p>给定一个矩阵 $A$ 和 一个向量 $\hat{b} = Ax + e$，其中 $e$ 是我们在一个固定数值范围内随机采集的一个随机噪音向量(扰动变量，服从某种公开的分布)，那么我们能否通过 $A$ 和 $\hat{b}$ 的值来还原(Learn)最初的未知数向量 $x$ ？</p>
<p>我们把这一类的问题称为 <strong>误差还原问题(LWE)。</strong></p>
<p>2005 年, Regev 提出了带错误的学习问题 (LWE), 证明了 LWE 与格上困难问题 (如近似最短向量问题 Gap-SVP) 相关, 并给出了基于 LWE 的公钥密码方案. 与之前出现的格上困难问题比较, LWE 在构建密码系统时更方便。</p>
<p>2.搜索LWE问题(Search LWE)</p>
<p>定义如下：</p>
<script type="math/tex; mode=display">
LWE(n,m,q,x_{B}):Search \quad Version \\
Let \, A \gets \mathbb{Z}_{q}^{m\times n},s \stackrel{R} \gets \mathbb{Z}_q ,e \stackrel{R} \gets x_{B}\\
Given(A,As+e),find \,s'\in \mathbb{Z}_{q}^{n}\,s.t. ||As'-(As+e)||_{\infty} \leq B \\</script><p>​    m：这个线性方程组有<strong>多少组方程</strong>，一般来说都是n的一个多项式倍数即 $m = poly(n)$。m越大，问题越简单。</p>
<p>​    n：每个方程中有<strong>多少个未知数</strong>，是LWE问题的安全参数(<strong>Security Parameter</strong>)，n越大，问题越难。</p>
<p>​    q：有限域 $\mathbb{Z}_{q}$ 的大小，一般会选足够大的素数，一般也是 n 的多项式倍数，可以设置 $q$ 为 $O(n^2)$ 。</p>
<p>​    B：误差上限，要满足$B &lt;&lt; q$ 。可理解为：LWE问题中 <strong>需要找到的解v</strong> 距离 <strong>实际取值</strong> $\hat{b}$ 究竟差多少。</p>
<p>所以LWE问题的本质就是：给定矩阵 $A$ 以及有误差的乘积 $As + e$，<strong>还原出未知的向量 $s$</strong> 。</p>
<p>困难性来源于方程的误差$e$。</p>
<p>LWE的直观困难性有很多：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">求解方法</th>
<th style="text-align:center">计算复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">穷举搜索</td>
<td style="text-align:center">$O(2^{nlog\, q})$</td>
</tr>
<tr>
<td style="text-align:center">搜索s</td>
<td style="text-align:center">$O(2^{nlog\, q})$</td>
</tr>
<tr>
<td style="text-align:center">q-ary格</td>
<td style="text-align:center">$O(2^n)$</td>
</tr>
</tbody>
</table>
</div>
<p>3.决策LWE问题(Decisonal LWE)</p>
<p>密码学中，一般需要证明一个困难问题的安全性的时候，我们一般都会使用<strong>决策版本的LWE问题（Decisional LWE）</strong>。决策LWE（简称为<strong>DLWE</strong>）的设定和搜索LWE（简称为<strong>SLWE</strong>）基本相同。</p>
<script type="math/tex; mode=display">
LWE(n,m,q,x_{B}):Decisional \quad Version \\
Let \, A \gets \mathbb{Z}_{q}^{m\times n},s \stackrel{R} \gets \mathbb{Z}_q ,e \stackrel{R} \gets x_{B},v \stackrel{R} \gets Z_{q}^{m} \\
Distinguish(A,As+e)from(A,v) \\</script><p>唯一不同的是，SLWE最后的问题是需要我们找到 $s$ ，而DLWE只需要让我们<strong>辨别</strong>看到的 $\hat{b}$ 到底是LWE问题中的<strong>误差乘积</strong> 还是 一个<strong>随机生成的向量</strong>。</p>
<h2 id="基于格的密码分析"><a href="#基于格的密码分析" class="headerlink" title="基于格的密码分析"></a>基于格的密码分析</h2><p>格理论第一次在密码学中应用, 是作为一种分析工具出现的。</p>
<p>很多非基于格的密码体制 的安全性分析，可以归约到求解格中困难问题，进而利用求解这些困难问题的算法进行分析。 这些研究从一开始就将基于经典数学难题— 分解因子问题 与 离散对数问题 的公钥密码体制的安全性分析的研究方法进行了<strong>跨学科的思维转换</strong>，从而让人们意识到格理论的研究对公钥密码分析的重要性 。</p>
<p>Shamir 在 1982 年第一次提出破解基本的 Merkel-Hellman 背包密码体制的多项式时间算法。其主要思想是利用 H. W. Lenstra 等人的理论，即利用<strong>多项式时间内求解关于固定数量变元的整数规划</strong> 解决背包密码算法中的问题。该方法是 LLL 算法的雏形。随后, Lagarias将背包问题归约为<strong>找格中的 短向量问题</strong>，通过更有效的 LLL 算法求解。 1985 年，Lagarias 和 Odlyzko 构造了一类格，利用 LLL 算法 求解格的短向量， 从而破解了密度小于 0. 6463 的背包体制。 后来通过构造不同的背包格,，该结果被 改进到 0.9408。</p>
<p>过去 30 年来该领域丰富的研究成果表明了该领域受关注的程度。 它的学科交叉所带来的许多数学问题不仅成为密码领域重点研究的内容， 也被数学领域与计算机科学领域所关注。格密码体制由于其运算具有线性特性比 RSA 等经典公钥密码体制具有更快的实现效率。 又由于该类密码体制安全性基于 NP-Hard 或者 NP-C 问题， 使得格密码体制成为抗量子攻击的密码体制中<strong>最核心研究领域</strong>。此外，由于格运算具有同态特性，因此设计格同态加密密码体制对于解决安全云计算环境下的密文检索，加密数据处理等方面具有潜在的应用价值。尽管如此，格密码理论还待于完善与发展， 无论是 理论研究 还是 实用化密码体制的设计 都具有很大的理论价值和实际意义。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://web.eecs.umich.edu/~cpeikert/pubs/lattice-survey.pdf">A Decade of Lattice Cryptography</a></p>
<p><a target="_blank" rel="noopener" href="https://kel.bz/post/lll/">Building Lattice Reduction (LLL) Intuition</a></p>
<p>王小云,刘明洁. 格密码学研究. <em>密码学报</em>. 2014, 1(1): 13-27 <a target="_blank" rel="noopener" href="https://doi.org/10.13868/j.cnki.jcr.000002">https://doi.org/10.13868/j.cnki.jcr.000002</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44885334/article/details/122271439">格基约化：LLL算法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43255133/article/details/83031862">格密码学习笔记（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266267223">如何用latex编写矩阵</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/528382661">latex公式左对齐</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://nexuslbh.top">NexusLbh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nexuslbh.top/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/">http://nexuslbh.top/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://nexuslbh.top" target="_blank">Meta Field</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SEC/">SEC</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/d6/wallhaven-d6ppwl.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/12/CSP-2209/" title="CSP_2209"><img class="cover" src="https://w.wallhaven.cc/full/9d/wallhaven-9d6q7d.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSP_2209</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/05/DES/" title="DES"><img class="cover" src="/img/tree.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-05</div><div class="title">DES</div></div></a></div><div><a href="/2022/07/22/MIT-CS6-858-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" title="MIT-CS6.858-计算机系统安全"><img class="cover" src="https://w.wallhaven.cc/full/n6/wallhaven-n67wqw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-22</div><div class="title">MIT-CS6.858-计算机系统安全</div></div></a></div><div><a href="/2022/04/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/" title="密码学概述"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9kl83.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">密码学概述</div></div></a></div><div><a href="/2022/10/13/%E6%A0%88%E6%BA%A2%E5%87%BA/" title="栈溢出"><img class="cover" src="/img/star.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-13</div><div class="title">栈溢出</div></div></a></div><div><a href="/2022/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/" title="计算机安全导论"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p9kl83.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-22</div><div class="title">计算机安全导论</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">NexusLbh</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NexusXDlbh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/NexusXDlbh" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3321861647@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">后量子密码-格密码学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">一.后量子密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">0x01 什么是后量子密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">0x02 为什么需要后量子密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%80%94%E5%BE%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">0x03 后量子密码算法实现途径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81%E5%BA%94%E7%94%A8%E7%8E%B0%E7%8A%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">0x04 后量子密码应用现状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6"><span class="toc-number">1.2.</span> <span class="toc-text">二.格密码学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x11-%E6%A0%BC%E5%AF%86%E7%A0%81%E7%AE%80%E5%8F%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">0x11 格密码简史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x12-%E6%A0%BC%E5%AF%86%E7%A0%81%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.2.</span> <span class="toc-text">0x12 格密码优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x13-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%8F%91%E5%B1%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">0x13 格密码发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x14-%E6%A0%BC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-Lattice"><span class="toc-number">1.2.4.</span> <span class="toc-text">0x14 格基本概念(Lattice)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x15-%E6%A0%BC%E7%9A%84%E5%9B%B0%E9%9A%BE%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">0x15 格的困难数学问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x16-%E9%AB%98%E6%96%AF%E6%A0%BC%E5%9F%BA%E7%BA%A6%E5%87%8F%E7%AE%97%E6%B3%95-Gauss-Lattice-Reduction"><span class="toc-number">1.2.6.</span> <span class="toc-text">0x16 高斯格基约减算法(Gauss Lattice Reduction)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x17-LLL%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.7.</span> <span class="toc-text">0x17 LLL算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x18-LWE-Learning-With-Errors"><span class="toc-number">1.2.8.</span> <span class="toc-text">0x18 LWE(Learning With Errors)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">基于格的密码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">1.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/" title="后量子密码-格密码学"><img src="https://w.wallhaven.cc/full/d6/wallhaven-d6ppwl.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="后量子密码-格密码学"/></a><div class="content"><a class="title" href="/2023/01/17/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/" title="后量子密码-格密码学">后量子密码-格密码学</a><time datetime="2023-01-17T09:33:19.272Z" title="更新于 2023-01-17 17:33:19">2023-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/12/CSP-2209/" title="CSP_2209"><img src="https://w.wallhaven.cc/full/9d/wallhaven-9d6q7d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSP_2209"/></a><div class="content"><a class="title" href="/2023/01/12/CSP-2209/" title="CSP_2209">CSP_2209</a><time datetime="2023-01-12T13:10:20.643Z" title="更新于 2023-01-12 21:10:20">2023-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" title="计算机是怎样跑起来的-linux0.11源代码学习"><img src="/img/cloud.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机是怎样跑起来的-linux0.11源代码学习"/></a><div class="content"><a class="title" href="/2022/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" title="计算机是怎样跑起来的-linux0.11源代码学习">计算机是怎样跑起来的-linux0.11源代码学习</a><time datetime="2023-01-08T13:12:26.399Z" title="更新于 2023-01-08 21:12:26">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/13/%E6%A0%88%E6%BA%A2%E5%87%BA/" title="栈溢出"><img src="/img/star.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈溢出"/></a><div class="content"><a class="title" href="/2022/10/13/%E6%A0%88%E6%BA%A2%E5%87%BA/" title="栈溢出">栈溢出</a><time datetime="2023-01-02T07:52:48.901Z" title="更新于 2023-01-02 15:52:48">2023-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/%E4%B8%80%E9%81%93%E8%AE%A1%E7%BB%84%E8%80%83%E7%A0%94%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" title="一道计组考研题的思考"><img src="/img/mout.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一道计组考研题的思考"/></a><div class="content"><a class="title" href="/2022/10/22/%E4%B8%80%E9%81%93%E8%AE%A1%E7%BB%84%E8%80%83%E7%A0%94%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" title="一道计组考研题的思考">一道计组考研题的思考</a><time datetime="2023-01-02T07:51:53.079Z" title="更新于 2023-01-02 15:51:53">2023-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/d6/wallhaven-d6ppwl.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By NexusLbh</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>